use crate::{chain_key::ChainKey, root_key::RootKey, receive_chain::ReceiveChain, key_exchange::KeyExchange, signed_public_key::SignedPublicKeyX448, signed_key_pair::{SignedKeyPairX448}, master_key::{MasterKey}, message::{Message, Type}, ntru::{self, NtruEncryptedKey, NtruedKeys, KeyPairNtru, PublicKeyNtru, PrivateKeyNtru}, chain::{Chain, self}, message_key, x448::{KeyPairX448, PublicKeyX448}, ed448::KeyPairEd448, id, mac::AxolotlMac, serializable::{Serializable, Deserializable}};

pub const RATCHETS_BETWEEN_NTRU: u32 = 20;

#[derive(PartialEq, Debug, Eq, Copy, Clone)]
pub enum Role {
	Alice = 0,
	Bob = 1
}

#[derive(Debug, PartialEq)]
pub enum Error {
	WrongNtruIdentity,
	UnknownNtruRatchet,
	NtruBadEncoding,
	NtruBadAesParams,
	NtruBadEphemeralKey,
	NtruWrongKey,
	NoRatchetSupplied,
	SkippedKeyMissing,
	NewCounterForOldChain,
	NewChainRequired,
	NoCurrentChain,
	NoLocalRatchet,
	NoLocalNtru,
	TooManyKeySkipped,
	WrongMessageKey,
	WrongMac
}

// TODO: test
impl From<ntru::Error> for Error {
	fn from(err: ntru::Error) -> Self {
		match err {
			ntru::Error::DecodeError => Self::NtruBadEncoding,
			ntru::Error::WrongKey => Self::NtruWrongKey,
			ntru::Error::BadAesParams => Self::NtruBadAesParams,
			ntru::Error::WrongEphKeyLen => Self::NtruBadAesParams,  // TODO: a dedicated error?
			ntru::Error::WrongNtruKeyLen => Self::NtruBadAesParams,
			ntru::Error::BadNtruedFormat => Self::NtruBadEphemeralKey,
			ntru::Error::BadNtruEncryptedFormat => Self::NtruBadEphemeralKey,
			ntru::Error::BadNtruEncryptedKeyFormat => Self::NtruBadEphemeralKey,
			ntru::Error::WrongNtruIdentity => Self::WrongNtruIdentity,
			ntru::Error::UnknownNtruRatchet => Self::UnknownNtruRatchet, // TODO: a dedicated error?
		}
	}
}

impl From<message_key::Error> for Error {
	fn from(key: message_key::Error) -> Self {
		match key {
			message_key::Error::BadKeyMaterial => Self::WrongMessageKey,
			message_key::Error::WrongMac => Self::WrongMac
		}
	}
}

impl From<chain::Error> for Error {
	fn from(_: chain::Error) -> Self {
		Self::TooManyKeySkipped
	}
}

#[derive(Debug, PartialEq)]
pub struct Session {
	id: u64,
	role: Role,
	receive_only: bool,

	counter: u32,
	prev_counter: u32, // prev sending chain len?
	ratchet_counter: u32,

	// saved for Bob only, alice uses her ntru_ratched instead; FIXME: move to Role? 
	my_ntru_identity: Option<KeyPairNtru>,

	// TODO: these two can be made non optional, if instead of resetting on decrypt a new ratched is generated
	my_ratchet: Option<KeyPairX448>, 
	my_ntru_ratchet: Option<KeyPairNtru>,

	// can be initially nil for Bob (until decrypt, plus, it can be ntru-encrypted itself)
	their_ratchet: Option<PublicKeyX448>,
	their_ratchet_ntru: PublicKeyNtru,

	unacked_key_exchange: Option<KeyExchange>, // FIXME: move to Role?

	root_key: RootKey,
	// TODO: can be made non optional if root_key is initialized in either alice/bob instead of encrypt as is now
	send_chain_key: Option<ChainKey>, 
	receive_chain: ReceiveChain
}

unsafe impl Send for Session {}

impl Session {
	pub fn id(&self) -> u64 {
		self.id
	}

	pub fn receive_only(&self) -> bool {
		self.receive_only
	}

	pub fn role(&self) -> Role {
		self.role
	}
}

impl Session {
	pub fn alice(my_identity: KeyPairX448, 
		my_ephemeral: KeyPairX448,
		my_signing_identity: KeyPairEd448,
		my_ntru_identity: KeyPairNtru,
		my_ntru_ratchet: KeyPairNtru,
		their_identity: PublicKeyX448,
		their_signed_prekey: SignedPublicKeyX448,
		their_prekey: PublicKeyX448,
		their_ntru_prekey: PublicKeyNtru,
		their_ntru_identity: PublicKeyNtru,
		force_reset: bool) -> Self {
			
			let id = KeyExchange::derive_id(my_identity.public_key(), their_prekey.id());
			let master_key = MasterKey::alice(&my_identity, &my_ephemeral, &their_identity, &their_signed_prekey, &their_prekey);
			let key_exchange = KeyExchange {
				x448_identity: my_identity.public_key().clone(),
				ntru_encrypted_ephemeral: ntru::encrypt_ephemeral(my_ephemeral.public_key(), my_ntru_ratchet.public_key(), ntru::EncryptionMode::Double { first_key: &their_ntru_prekey, second_key: &their_ntru_identity }),
				ntru_identity: my_ntru_identity.public_key().clone(),
				ed448_identity: my_signing_identity.public_key().clone(),
				signed_prekey_id: their_signed_prekey.key().id(),
				x448_prekey_id: their_prekey.id(),
				force_reset
			};

			Self {
				id,
				role: Role::Alice,
				receive_only: false,
				counter: 0,
				prev_counter: 0,
				ratchet_counter: 0,
				my_ntru_identity: Some(my_ntru_identity),
				my_ratchet: None,
				my_ntru_ratchet: Some(my_ntru_ratchet),
				their_ratchet: Some(their_prekey),
				their_ratchet_ntru: their_ntru_prekey,
				unacked_key_exchange: Some(key_exchange),
				root_key: *master_key.root_key(),
				send_chain_key: None, 
				receive_chain: ReceiveChain::new() // REVIEW: make optional?
			}
	}

	pub fn bob(my_identity: KeyPairX448,
		my_ntru_identity: KeyPairNtru,
		my_signed_prekey: SignedKeyPairX448,
		my_prekey: KeyPairX448,
		my_ntru_prekey: KeyPairNtru,
		their_identity: PublicKeyX448,
		their_ephemeral: PublicKeyX448,
		their_ratchet_ntru: PublicKeyNtru) -> Self {
			let id = KeyExchange::derive_id(&their_identity, my_prekey.public_key().id());
			let master_key = MasterKey::bob(&my_identity, &my_signed_prekey, &my_prekey, &their_identity, &their_ephemeral);

			Self {
				id,
				role: Role::Bob, 
				receive_only: false,
				counter: 0, 
				prev_counter: 0, 
				ratchet_counter: 0,
				my_ntru_identity: Some(my_ntru_identity), 
				my_ratchet: Some(my_prekey), 
				my_ntru_ratchet: Some(my_ntru_prekey),
				their_ratchet: None, 
				their_ratchet_ntru, 
				unacked_key_exchange: None,
				root_key: *master_key.root_key(),
				send_chain_key: None, // REVIEW: master_key.chain_key? â€“rather not, for it's not used until encrypt
				receive_chain: ReceiveChain::new() 
			}
	}
}

impl Session {
	pub fn set_receive_only(&mut self) {
		self.receive_only = true
	}

	pub fn force_ntru_for_next(&mut self) {
		self.ratchet_counter = RATCHETS_BETWEEN_NTRU;
	}

	// TODO: return result
	pub fn encrypt(&mut self, plaintext: &[u8], message_type: Type) -> AxolotlMac {
		if self.my_ratchet.is_none() {
			if self.ratchet_counter == RATCHETS_BETWEEN_NTRU {
				self.ratchet_counter = 0;
				self.my_ntru_ratchet = Some(KeyPairNtru::generate()); // TODO: don't generate, but inject instead
			}

			self.ratchet_counter += 1;
			self.my_ratchet = Some(KeyPairX448::generate()); // TODO: don't generate, but inject instead

			// REVIEW: do I need MasterKey at all?
			// TODO: don't hard unwrap
			let (ck, rk) = MasterKey::derive(&self.root_key, self.my_ratchet.as_ref().unwrap(), self.their_ratchet.as_ref().unwrap()).into(); 

			self.send_chain_key = Some(ck);
			self.root_key = rk;

			self.prev_counter = self.counter;
			self.counter = 0;
		}

		let mut msg = Message::new(message_type);

		if let Some(ref my_ntru_ratchet) = self.my_ntru_ratchet {
			// TODO: don't hard unwrap
			msg.set_ntru_encrypted_ratchet_key(ntru::encrypt_ephemeral(self.my_ratchet.as_ref().unwrap().public_key(), my_ntru_ratchet.public_key(), ntru::EncryptionMode::Once { key: &self.their_ratchet_ntru }));
		} else {
			msg.set_ratchet_key(self.my_ratchet.as_ref().unwrap().public_key().clone());
		}

		msg.set_counter(self.counter);
		msg.set_prev_counter(self.prev_counter);
		msg.set_key_exchange(self.unacked_key_exchange.clone());

		// TODO: don't hard unwrap
		let mk = self.send_chain_key.as_ref().unwrap().message_key(); 
		let mac = mk.encrypt(plaintext, &mut msg);

		self.counter += 1;
		// TODO: don't hard unwrap
		self.send_chain_key = Some(self.send_chain_key.as_ref().unwrap().next());

		mac
	}

	fn decrypt_ntru_encrypted_ratchet(&self, eph: &NtruEncryptedKey) -> Result<NtruedKeys, Error> {
		use ntru::DecryptionMode::{Once, Double};

		let find_key = |id| -> Result<&PrivateKeyNtru, ntru::Error> {
			// TODO: check key id? it'll fail decrypting anyway, if somethign goes wrong
			Ok(self.receive_chain.ntru_key_pair(id).or(self.my_ntru_ratchet.as_ref()).ok_or(ntru::Error::UnknownNtruRatchet)?.private_key())
		};

		if eph.double_encrypted {
			// second key is the outer key, while the first key is the inner one, ie `encrypt(encrypt(data, first), second)
			let second_key = self.my_ntru_identity.as_ref().ok_or(Error::NoLocalNtru)?.private_key();

			Ok(ntru::decrypt_ephemeral(eph, Double { second_key, first_key: Box::new(find_key) })?)
		} else {
			Ok(ntru::decrypt_ephemeral::<ntru::KeySource>(eph, Once { key: find_key(eph.payload.encryption_key_id)? })?)
		}
	}

	fn decrypt_with_current_or_past_chain(&mut self, mac: &AxolotlMac, purported_ratchet: &PublicKeyX448) -> Result<Option<Vec<u8>>, Error> {
		// TODO: introduce Chain.id()
		if let Some(current) = self.receive_chain.current().map(|c| c.ratchet_key().id()) {
			if let Some(chain) = self.receive_chain.chain_mut(purported_ratchet) {
				let counter = mac.body().counter();

				if counter < chain.next_counter() {
					let skipped = chain.skipped_key(counter).ok_or(Error::TooManyKeySkipped)?; // what if not found? can it be?
					let decrypted = skipped.decrypt(mac)?;

					chain.remove(counter);

					// TODO: introduce Chain.id()
					if current != chain.ratchet_key().id() && !chain.has_skipped_keys() {
						self.receive_chain.remove_by_ratchet_key_id(current);
					}

					return Ok(Some(decrypted));
				} else {
					// TODO: introduce Chain.id()
					if chain.ratchet_key().id() != current {
						return Err(Error::NewCounterForOldChain);
					} else {
						let next = chain.stage(counter)?;
						let mk = next.message_key();
						let decrypted = mk.decrypt(mac)?;

						next.commit();

						return Ok(Some(decrypted));
					}
				}
			}
		}

		// no chain found -> create a new ratchet
		Ok(None)
	}

	// TODO: return Result
	pub fn decrypt(&mut self, mac: &AxolotlMac) -> Result<Vec<u8>, Error> {
		let msg = mac.body();
		let purported_ratchet: PublicKeyX448; // TODO: can I get rid of this?
		let purported_ntru_ratchet: PublicKeyNtru; // TODO: can I get rid of this?

		if let Some(ntru_encrypted_ratchet) = msg.ntru_encrypted_ratchet_key() {
			let NtruedKeys { ephemeral, ntru } = self.decrypt_ntru_encrypted_ratchet(ntru_encrypted_ratchet)?;

			purported_ratchet = ephemeral;
			purported_ntru_ratchet = ntru;
		} else {
			purported_ratchet = msg.ratchet_key().ok_or(Error::NoCurrentChain)?.clone();
			purported_ntru_ratchet = self.their_ratchet_ntru.clone();
		}

		// TODO: switch instead
		if let Some(decrypted) = self.decrypt_with_current_or_past_chain(mac, &purported_ratchet)? {
			return Ok(decrypted);
		}

		let my_ratchet = self.my_ratchet.as_ref().ok_or(Error::NoLocalRatchet)?;

		// the sender used this ratchet for the 1st time, so let's dh-rotate
		let (ck, rk) = MasterKey::derive(&self.root_key, my_ratchet, &purported_ratchet).into();
		let current = self.receive_chain.current_mut();
		let mut new_chain = Chain::new(purported_ratchet.clone(), ck, chain::MAX_KEYS_TO_SKIP);

		if let Some(ref my_ntru) = self.my_ntru_ratchet {
			new_chain.set_ntru_ratchet_key(my_ntru.clone());
		} else if let Some(ref current) = current {
			new_chain.set_ntru_ratchet_key(current.ntru_ratchet_key().as_ref().unwrap().clone()); // TODO: don't hard unwrap
		}

		let next = new_chain.stage(msg.counter()).unwrap(); // TODO: don't hard unwrap

		let decrypted = next.message_key().decrypt(mac)?;
		next.commit();

		if let Some(current) = current {
			current.stage(msg.prev_counter()).unwrap().commit(); // TODO: don't hard unwrap
		}

		self.receive_chain.set_current(new_chain);

		self.root_key = rk;
		self.their_ratchet = Some(purported_ratchet);
		self.their_ratchet_ntru = purported_ntru_ratchet;
		self.my_ratchet = None;
		self.my_ntru_ratchet = None;
		self.unacked_key_exchange = None;

		Ok(decrypted)
	}
}

#[cfg(test)]
mod tests {
	use crate::{x448::{KeyPairX448}, ed448::KeyPairEd448, ntru::{KeyPairNtru, PrivateKeyNtru, NtruedKeys, self}, signed_key_pair::{SignedKeyPairX448}, signed_public_key::SignedPublicKeyX448, key_exchange::KeyExchange, message::Type, session::RATCHETS_BETWEEN_NTRU, chain, hmac};
	use super::{Session, AxolotlMac, Error};

	fn alice_x448_identity() -> KeyPairX448 {
		let private = b"\x00\xc4\x0a\x23\x46\x32\x7e\x1c\x19\x0d\xac\x29\x0c\xb3\x8e\x41\x79\x73\x52\x43\x00\x4f\xb3\xae\x4f\xc4\x82\xf4\xb0\xa2\x57\x66\x48\xa5\xe8\xab\xc0\x06\x93\x4f\x78\xfe\x7b\xe7\x67\x11\x65\x4d\x9a\x55\x5a\xe9\x28\x93\x0b\x80";
		let public = b"\xd7\x32\x4f\x46\xc1\xa5\x1d\xbf\xef\x1a\xe4\xa8\xe9\x1e\x51\x07\xc4\x17\x9b\x6f\xc4\xa6\xb5\x97\xb1\x21\x7a\x9a\x5f\xb9\x48\xe0\xc0\xa7\xcc\x66\x1f\x1b\x3e\xdf\x60\x5c\x58\x52\xc7\xcd\x09\xc2\xbd\x0a\xf7\x67\x89\x54\xc3\xdf";

		KeyPairX448::new(private.into(), public.into())
	}

	fn alice_ephemeral() -> KeyPairX448 {
		let private = b"\xe0\x9e\x9a\x46\x9f\x2d\xf0\x6b\x71\x8a\x00\x38\xef\x46\xac\xd2\x0c\x00\x0a\x6d\x6f\xaf\x74\x71\x8e\xf6\x6a\x5c\x3a\x3c\xd4\x5d\x15\x0a\x30\x70\x37\xdf\x6c\x69\x4c\xd0\x98\x81\x48\x71\xe9\x35\xf4\xe4\x6b\xc1\x12\x81\xc2\xa0";
		let public = b"\x43\x6a\xa5\xc5\x72\x9a\xc9\x54\x5b\x7e\x11\xd3\x96\x6a\xc4\x7d\x20\x5c\x12\xbb\x5b\x7d\x81\x73\xae\xd5\x32\x50\x51\x4c\x3e\x51\xe8\x1b\xeb\x9b\x3a\xed\x32\x23\x5f\x3e\xb9\x9e\x8e\xca\x81\x6b\x33\x27\x84\xba\x54\x6c\x8d\xd3";

		KeyPairX448::new(private.into(), public.into())
	}

	fn alice_ntru_ratchet() -> KeyPairNtru {
		let private = b"\x02\x03\x00\x06\x10\x50\x16\x73\xcf\xb9\x72\x73\x22\x43\x21\x51\x0e\x45\x22\x95\x5f\x4e\xa1\x18\x8b\x76\xa3\x44\xbe\x75\xd8\xa5\x0f\x60\x4d\x04\x73\xc8\x9c\xa4\x2a\x0f\x8a\x8d\x74\x63\x67\xde\xe8\xbd\xc4\x9e\xa1\xd6\x7a\x43\x99\x3d\x8f\x42\xf1\xd5\x7d\xab\x65\x0f\xa7\x58\xa5\xcd\xa3\xc2\xc9\x72\x4f\xe3\x8f\x81\x59\xcd\xf4\x5c\x87\x38\xd7\xbc\xf3\x46\xd1\x6d\x11\x01\x72\xa9\x2a\x20\x27\x72\x8b\x3d\xfb\xa0\xb7\xbd\x81\x1a\x6b\x67\x3a\xbe\x15\x6f\x84\xde\xa1\x44\xc8\x13\x4c\xb2\x75\x2f\x64\x2e\x08\xae\x30\x4a\xb5\x7c\x9d\x56\xac\xa7\xcb\x2e\x6a\x10\x05\x5f\x33\xd3\x77\x15\xa9\xfe\x1a\xa0\xc5\x9b\x88\xd8\xe0\x4f\x8e\xe5\x5e\xa4\xad\xe2\x94\x25\xe5\x99\x97\xa4\x7c\x13\x88\x1c\x21\xec\x87\xdc\x92\xa9\xa6\xfa\xa5\xa7\x57\x46\x97\xb1\x44\x2f\x50\x9d\x1a\xf0\x1d\x75\xe7\x52\x3b\xfb\x45\x74\x7e\x44\x19\xcc\xbf\x55\x6e\x60\x1c\x04\xaf\x26\x95\xcb\x73\xa2\xe8\xe1\x80\xc7\x31\x86\xab\x4e\x9f\x42\x15\x4f\xc2\xaf\x6e\x37\xeb\x5c\xdd\x7e\x01\x7c\xcc\xb6\xdc\xbe\xcc\x29\x7c\xe4\x11\xe9\xd5\xbd\x58\x5e\xc6\x83\x9e\x88\x60\x33\xc1\x22\xfc\x80\x30\x6d\x13\x04\xc3\x9a\x6c\xab\x57\x9e\x14\xad\x84\x5a\xff\x4f\x0c\xb3\x85\xe8\xd5\xcc\xc2\x7d\x4a\xac\xc2\x57\xc3\x7b\xab\xed\x4b\x58\x10\x09\x76\x84\x8b\x00\x80\xa8\xde\xa4\x68\xd4\x9b\x57\xfd\x8f\xcf\x81\xb5\xac\x84\x68\xa9\xbc\xa3\xc4\x5b\x69\x61\x9e\xa6\x1c\x61\xfd\x1d\xbe\x57\x18\x46\x1a\x80\x08\x53\xc0\xa9\xb4\x73\x30\xad\x4c\x44\xd0\x38\x58\x5a\x71\x06\xe4\x65\xf8\xc0\x57\x44\x9d\x2b\xfe\x71\xb1\x54\x56\xb5\x51\x5d\xb4\x1b\x58\x09\x8c\x22\x70\x1f\x25\xc0\x38\x24\x17\x53\xb9\x03\x7a\x64\x24\x12\x8d\xb7\xc9\xc2\x9c\x67\xfb\x16\x40\x31\x1f\x2a\xae\xc9\x0b\xe6\x15\xe3\x0a\xd6\xd7\x31\x3f\xfb\xa3\x26\xe4\x2b\x8f\x5f\xa5\xd6\x0d\x5e\x5c\x61\x0f\xb3\x6e\x2c\xdd\x01\x70\x70\x93\x92\x58\x30\xfb\x3d\x42\x37\x02\x6e\x94\x5d\x03\xa7\xcf\x50\xf4\xf1\x0d\x39\x90\xea\x03\xdf\xbc\x6d\x47\x95\x65\x2a\xbf\x07\xbe\x0d\x33\x23\xdc\x4a\x6a\x5d\xb2\x01\x6f\x1f\x29\xc6\xfb\xc8\xd5\x2f\x7c\x05\x7b\xf9\xa5\x84\xee\xc3\xd6\x41\xf4\xb4\xad\xa1\x28\x6a\x5d\x88\x3d\x65\x62\x4a\xa0\xd7\xca\x8b\x16\x45\x19\x4b\xec\x09\x61\xa4\xfd\x7a\x4c\x9c\x86\x76\xf3\x3a\xe1\x8f\x2d\x96\x84\xd7\xd4\x91\x46\x16\x71\xcc\x15\x6e\x4a\x47\x65\x2b\xa0\xf5\x4f\x74\xa2\x5e\x16\x5d\x09\x7d\x72\xe2\x3c\x34\x76\xbc\x90\x30\x08\x88\x1b\xf6\x6f\xa5\x75\xf9\x89\x4c\xbb\x03\x08\xbc\x15\xbf\x62\x7c\x4c\x9a\x01\x44\x8b\x7f\x28\x58\x15\x8c\x20\xef\x9f\xe8\x36\x6f\xe1\x97\xe0\x5b\x8d\xdc\x47\x0d\x53\xa1\x0b\x5d\x72\x6f\x28\xae\x88\xd7\xbb\xb7\x56\x05\x51\x15\x29\xd8\xf4\x30\x80\x99\x91\xe0\x91\x71\x1a\x5d\x3a\xb6\x16\x42\xa3\x20\xe4\x28\x76\xf0\x06\xcf\x55\xa0\x5e\x0c\xa7\xd8\x4c\xd5\x73\x9d\x2d\x92\x9b\x73\x80\x80\x8c\x5f\x3b\xcd\x61\xf2\xb3\x40\x5e\x30\xd9\x31\xe1\x91\x6c\x61\x80\x3c\x24\x30\xa0\x33\xa5\x90\x4f\x12\x52\x8e\x80\x19\xae\xcc\x91\x2d\x22\xe6\x2a\xbb\xcc\x2c\xc8\x66\x09\x2b\x48\xae\xc1\x7c\x08\x13\xe8\x1a\xf7\xc4\x1f\x9f\x31\xee\xe2\x59\x02\x9d\x10\x39\xcc\x2a\xb1\x95\x8d\x2d\x52\xa9\x81\x45\x4b\x53\x27\x07\x24\x48\x20\x80\xf1\x29\xbf\x49\x3c\xa2\x2e\x51\x15\xa9\x82\x10\xc4\x5a\x97\xe0\x6c\x61\x60\x93\x0d\x32\x58\x08\x7f\xd3\xc6\x86\x85\xfc\x9a\xfb\x00\xce\x59\xa5\x0c\xa7\x7d\xfc\xd9\x5b\x80\x80\x11\x9a\xe4\x11\xec\xfd\x6f\xe5\xc8\x95\xe1\x47\x49\xe3\x85\x36\xec\x39\xe1\xa7\x73\x43\x63\xd7\xab\x99\x13\x7d\x4b\xc7\x86\x17\xc2\xf7\xc1\xd4\xb7\x5a\x7d\xa0\x7b\xda\xbc\x62\x90\x7a\x56\xa8\xa9\x81\x95\xe6\xfe\xc3\x5e\xe8\x0a\xe6\x72\x63\x45\x35\x7d\x76\x88\x9e\x36\x0e\x9b\xba\xd8\xba\x7f\xd9\xf8\x47\xea\x20\x27\x6e\xf5\xef\x85\x42\xf4\x24\xdd\xba\xc6\xdd\x1a\xf1\x69\xac\xc8\x37\xe5\x23\xe6\xdd\x25\x99\x14\x59\x06\x1a\x49\xfc\x4c\x40\xd1\x19\xd3\xeb\xe3\xfd\xa6\x6a\x7d\xe5\x12\xd8\x59\x2d\xba\x12\xd1\x16\x4a\x54\xb7\xed\x20\xe0\x67\xb5\xdf\xfb\x44\xe6\x2e\x14\xd4\x51\x61\xb2\xbd\x73\x9a\x9d\x16\x2d\x40\x3d\x83\xf5\xce\x82\xb2\xb0\xfd\x65\x9a\xe7\x73\x3b\xc7\x4e\x91\xbe\xc2\x8a\xe4\xef\xc2\x96\xbf\x6a\x48\x56\x04\x5c\x66\x34\xdb\x7b\x9d\x4b\x88\x19\x46\x75\xef\xc0\x06\x75\x4b\xb3\x45\xa8\xe8\xbd\x67\x18\x84\x70\x50\x7e\xa4\xa1\xf0\xca\xd4\x49\x0e\xe5\x84\x02\x18\xcd\xf4\xf2\x46\xf9\x03\xeb\xe3\x79\x5a\xc0\xd1\x38\x82\xde\xea\xa9\x4e\x1b\x90\x9b\x86\xb5\x2c\xf0\xad\x0a\xa8\x58\x87\x23\xe8\xda\x3c\x86\x32\xad\x67\x86\xd2\x45\xa4\x92\x44\x09\x27\x5b\xf3\x40\x41\x1e\x29\x6a\x22\x97\x5b\xa5\x36\x00\x71\x2e\xab\xf5\x65\x61\xb7\x2b\x62\xb0\x23\x42\x58\xf6\x29\x8b\x00\xa0\xb3\xec\x7c\x6e\x07\x0b\x46\xb4\x9a\x01\xf6\xa6\x1e\x14\x1c\xc0\x44\x36\x5b\x2c\x36\x15\x92\x43\xcc\xd4\x64\x3c\x80\xd8\x17\x01\xa3\x90\x18\xe6\x6c\x6f\x3f\x5f\x80";
		let public = b"\x01\x03\x00\x06\x10\x50\x16\x73\xcf\xb9\x72\x73\x22\x43\x21\x51\x0e\x45\x22\x95\x5f\x4e\xa1\x18\x8b\x76\xa3\x44\xbe\x75\xd8\xa5\x0f\x60\x4d\x04\x73\xc8\x9c\xa4\x2a\x0f\x8a\x8d\x74\x63\x67\xde\xe8\xbd\xc4\x9e\xa1\xd6\x7a\x43\x99\x3d\x8f\x42\xf1\xd5\x7d\xab\x65\x0f\xa7\x58\xa5\xcd\xa3\xc2\xc9\x72\x4f\xe3\x8f\x81\x59\xcd\xf4\x5c\x87\x38\xd7\xbc\xf3\x46\xd1\x6d\x11\x01\x72\xa9\x2a\x20\x27\x72\x8b\x3d\xfb\xa0\xb7\xbd\x81\x1a\x6b\x67\x3a\xbe\x15\x6f\x84\xde\xa1\x44\xc8\x13\x4c\xb2\x75\x2f\x64\x2e\x08\xae\x30\x4a\xb5\x7c\x9d\x56\xac\xa7\xcb\x2e\x6a\x10\x05\x5f\x33\xd3\x77\x15\xa9\xfe\x1a\xa0\xc5\x9b\x88\xd8\xe0\x4f\x8e\xe5\x5e\xa4\xad\xe2\x94\x25\xe5\x99\x97\xa4\x7c\x13\x88\x1c\x21\xec\x87\xdc\x92\xa9\xa6\xfa\xa5\xa7\x57\x46\x97\xb1\x44\x2f\x50\x9d\x1a\xf0\x1d\x75\xe7\x52\x3b\xfb\x45\x74\x7e\x44\x19\xcc\xbf\x55\x6e\x60\x1c\x04\xaf\x26\x95\xcb\x73\xa2\xe8\xe1\x80\xc7\x31\x86\xab\x4e\x9f\x42\x15\x4f\xc2\xaf\x6e\x37\xeb\x5c\xdd\x7e\x01\x7c\xcc\xb6\xdc\xbe\xcc\x29\x7c\xe4\x11\xe9\xd5\xbd\x58\x5e\xc6\x83\x9e\x88\x60\x33\xc1\x22\xfc\x80\x30\x6d\x13\x04\xc3\x9a\x6c\xab\x57\x9e\x14\xad\x84\x5a\xff\x4f\x0c\xb3\x85\xe8\xd5\xcc\xc2\x7d\x4a\xac\xc2\x57\xc3\x7b\xab\xed\x4b\x58\x10\x09\x76\x84\x8b\x00\x80\xa8\xde\xa4\x68\xd4\x9b\x57\xfd\x8f\xcf\x81\xb5\xac\x84\x68\xa9\xbc\xa3\xc4\x5b\x69\x61\x9e\xa6\x1c\x61\xfd\x1d\xbe\x57\x18\x46\x1a\x80\x08\x53\xc0\xa9\xb4\x73\x30\xad\x4c\x44\xd0\x38\x58\x5a\x71\x06\xe4\x65\xf8\xc0\x57\x44\x9d\x2b\xfe\x71\xb1\x54\x56\xb5\x51\x5d\xb4\x1b\x58\x09\x8c\x22\x70\x1f\x25\xc0\x38\x24\x17\x53\xb9\x03\x7a\x64\x24\x12\x8d\xb7\xc9\xc2\x9c\x67\xfb\x16\x40\x31\x1f\x2a\xae\xc9\x0b\xe6\x15\xe3\x0a\xd6\xd7\x31\x3f\xfb\xa3\x26\xe4\x2b\x8f\x5f\xa5\xd6\x0d\x5e\x5c\x61\x0f\xb3\x6e\x2c\xdd\x01\x70\x70\x93\x92\x58\x30\xfb\x3d\x42\x37\x02\x6e\x94\x5d\x03\xa7\xcf\x50\xf4\xf1\x0d\x39\x90\xea\x03\xdf\xbc\x6d\x47\x95\x65\x2a\xbf\x07\xbe\x0d\x33\x23\xdc\x4a\x6a\x5d\xb2\x01\x6f\x1f\x29\xc6\xfb\xc8\xd5\x2f\x7c\x05\x7b\xf9\xa5\x84\xee\xc3\xd6\x41\xf4\xb4\xad\xa1\x28\x6a\x5d\x88\x3d\x65\x62\x4a\xa0\xd7\xca\x8b\x16\x45\x19\x4b\xec\x09\x61\xa4\xfd\x7a\x4c\x9c\x86\x76\xf3\x3a\xe1\x8f\x2d\x96\x84\xd7\xd4\x91\x46\x16\x71\xcc\x15\x6e\x4a\x47\x65\x2b\xa0\xf5\x4f\x74\xa2\x5e\x16\x5d\x09\x7d\x72\xe2\x3c\x34\x76\xbc\x90\x30\x08\x88\x1b\xf6\x6f\xa5\x75\xf9\x89\x4c\xbb\x03\x08\xbc\x15\xbf\x62\x7c\x4c\x9a\x01\x44\x8b\x7f\x28\x58\x15\x8c\x20\xef\x9f\xe8\x36\x6f\xe1\x97\xe0\x5b\x8d\xdc\x47\x0d\x53\xa1\x0b\x5d\x72\x6f\x28\xae\x88\xd7\xbb\xb7\x56\x05\x51\x15\x29\xd8\xf4\x30\x80\x99\x91\xe0\x91\x71\x1a\x5d\x3a\xb6\x16\x42\xa3\x20\xe4\x28\x76\xf0\x06\xcf\x55\xa0\x5e\x0c\xa7\xd8\x4c\xd5\x73\x9d\x2d\x92\x9b\x73\x80\x80\x8c\x5f\x3b\xcd\x61\xf2\xb3\x40\x5e\x30\xd9\x31\xe1\x91\x6c\x61\x80\x3c\x24\x30\xa0\x33\xa5\x90\x4f\x12\x52\x8e\x80\x19\xae\xcc\x91\x2d\x22\xe6\x2a\xbb\xcc\x2c\xc8\x66\x09\x2b\x48\xae\xc1\x7c\x08\x13\xe8\x1a\xf7\xc4\x1f\x9f\x31\xee\xe2\x59\x02\x9d\x10\x39\xcc\x2a\xb1\x95\x8d\x2d\x52\xa9\x81\x45\x4b\x53\x27\x07\x24\x48\x20\x80\xf1\x29\xbf\x49\x3c\xa2\x2e\x51\x15\xa9\x82\x10\xc4\x5a\x97\xe0\x6c\x61\x60\x93\x0d\x32\x58\x08\x7f\xd3\xc6\x86\x85\xfc\x9a\xfb\x00\xce\x59\xa5\x0c\xa7\x7d\xfc\xd9\x5b\x80\x80\x11\x9a\xe4\x11\xec\xfd\x6f\xe5\xc8\x95\xe1\x47\x49\xe3\x85\x36\xec\x39\xe1\xa7\x73\x43\x63\xd7\xab\x99\x13\x7d\x4b\xc7\x86\x17\xc2\xf7\xc1\xd4\xb7\x5a\x7d\xa0\x7b\xda\xbc\x62\x90\x7a\x56\xa8\xa9\x81\x95\xe6\xfe\xc3\x5e\xe8\x0a\xe6\x72\x63\x45\x35\x7d\x76\x88\x9e\x36\x0e\x9b\xba\xd8\xba\x7f\xd9\xf8\x47\xea\x20\x27\x6e\xf5\xef\x85\x42\xf4\x24\xdd\xba\xc6\xdd\x1a\xf1\x69\xac\xc8\x37\xe5\x23\xe6\xdd\x25\x99\x14\x59\x06\x1a\x49\xfc\x4c\x40\xd1\x19\xd3\xeb\xe3\xfd\xa6\x6a\x7d\xe5\x12\xd8\x59\x2d\xba\x12\xd1\x16\x4a\x54\xb7\xed\x20\xe0\x67\xb5\xdf\xfb\x44\xe6\x2e\x14\xd4\x51\x61\xb2\xbd\x73\x9a\x9d\x16\x2d\x40\x3d\x83\xf5\xce\x82\xb2\xb0\xfd\x65\x9a\xe7\x73\x3b\xc7\x4e\x91\xbe\xc2\x8a\xe4\xef\xc2\x96\xbf\x6a\x48\x56\x04\x5c\x66\x34\xdb\x7b\x9d\x4b\x88\x19\x46\x75\xef\xc0\x06\x75\x4b\xb3\x45\xa8\xe8\xbd\x67\x18\x84\x70\x50\x7e\xa4\xa1\xf0\xca\xd4\x49\x0e\xe5\x84\x02\x18\xcd\xf4\xf2\x46\xf9\x03\xeb\xe3\x79\x5a\xc0\xd1\x38\x82\xde\xea\xa9\x4e\x1b\x90\x9b\x86\xb5\x2c\xf0";

		KeyPairNtru::new(private.into(), public.into())
	}

	fn alice_ed448_identity() -> KeyPairEd448 {
		let private = b"\x84\x97\xd6\xcf\xc5\xaa\x5e\xb8\xfd\x80\xfe\x31\x12\x3f\x16\x05\xd2\xbb\x55\x11\x63\x3f\x3e\x58\x4e\x39\xef\xea\x9c\x3c\x47\x61\xb8\x93\xa2\x79\xe7\xf9\xc8\xa7\x0d\x52\x0b\x03\x84\x80\x51\xdc\x82\xfe\xf6\x9e\xe7\x67\x24\x61\xca";
		let public = b"\xab\x32\x7e\x4c\xe7\x75\x8f\xdc\x2c\x91\x9d\x90\xe8\x6b\x1f\x88\x2e\x19\xe8\xfe\x84\x36\xf3\x90\xd3\xf0\x22\x47\xff\xf1\x2f\xc1\x18\xec\x5c\x09\xdc\x9e\x41\xff\x83\x23\x63\x14\x34\x10\x0f\xd5\x11\xb0\xaa\x0e\x00\x63\xd7\x56\x80";

		KeyPairEd448::new(private.into(), public.into())
	}

	fn alice_ntru_identity() -> KeyPairNtru {
		let private = b"\x02\x03\x00\x06\x10\xa6\x4b\x37\x7d\xb9\xba\x78\x61\x8f\xbf\xf9\x7e\x4f\x9c\xbc\xd4\xdd\x37\xf8\xca\xd5\x37\xc3\xcc\xd1\x50\xe8\xab\x05\x2c\x01\xf5\x60\xed\x58\x05\xb4\x5d\x2f\x67\xaa\xb0\x2d\x0f\x89\xda\x2f\x44\x40\x9a\x78\xe1\xb3\x35\x3f\xc1\xaf\xa7\xd7\x76\x12\xe7\xf7\xae\x2e\xee\x60\x2f\xba\x45\x7e\x38\x1b\x4d\xaa\xdc\x85\xab\x75\x2d\x2d\x2a\xe5\x8d\x5e\xe3\x16\x99\x23\x33\x06\x84\xfe\xaf\x63\xe3\x29\x6e\xfe\x8b\x1d\x89\x6c\x84\x2f\x8a\x36\xd8\x9f\x5d\xcf\xc9\x74\xe5\x4b\x5c\x2d\x4b\x7a\xea\x3b\x61\x84\x8a\xc5\xe1\xd9\x2b\x4a\xac\x16\x0a\x80\xf6\xac\x08\xdd\x1d\xa2\xc5\xed\x42\x5f\x89\x27\xae\xd9\x02\xee\x3a\xd9\x58\xbf\x53\xdb\x45\x6e\xc3\x58\x2d\x67\x36\xf1\xec\x1d\x06\xdd\x92\x43\x86\x5c\xa3\x61\xf1\xad\x1c\x07\xbe\xca\xb7\x7b\x7f\x31\x45\x1c\x84\x79\x68\xc5\x0c\x44\x97\x38\x5d\xe9\x7c\xbd\x6c\xcf\x5c\x02\xd9\xb2\x56\x43\xc1\xb9\x6c\x3d\x82\x31\xf4\xb7\x30\x61\x01\xdc\x67\x83\xde\x04\x37\x5e\x5a\x4c\x3a\xe4\x32\xba\x5d\x01\x18\x66\xc0\x1e\x62\xc7\x7e\x8c\x93\xa5\x65\xd3\xe7\xa9\x92\x90\x6e\xc7\xb9\x72\x13\xaa\xe8\x59\xf5\x26\x33\xca\x94\xe8\x0c\xff\xdb\x75\x41\x18\x04\xc6\xaa\x02\x48\x21\xce\x42\x3c\x2b\x6a\x66\x54\x05\x28\xa8\xba\xc5\xee\x7b\xe4\x19\x08\x43\x49\x9f\xa5\xd5\x5e\x5b\xc1\x57\xe5\x04\x62\x6e\x0f\x04\x0a\xea\x5a\x94\x7d\xcb\x7d\xf1\xb1\xfe\xab\x79\x85\x16\x82\x87\xc7\xf0\x1c\x59\xe5\x07\xeb\xc2\xa0\xa9\x01\xcd\x56\x06\x23\x1e\x7b\x94\xb7\x8b\x1f\x2b\x63\x4e\x01\xd8\x6c\x14\xfa\x9c\x32\xcc\x81\x02\xaa\x0f\xb5\x2e\x0b\x75\x92\x46\x02\x8e\xde\x5e\x9c\x12\x58\xf4\x78\xe0\xe9\xfb\xab\x0c\xcc\xc4\x9e\x20\x8b\xcc\xdc\xde\xbe\xb7\xa3\xed\x52\x7e\xae\x69\x69\x29\x34\x9e\xf0\x34\x9f\x5c\xa9\xa8\xd2\xc1\x94\x95\xde\x6b\xea\x9e\xb4\xcb\xc2\x49\xf1\x75\x12\x30\x84\x71\xa0\xe2\x66\x6c\xda\xe0\xc3\x52\x7a\xef\x6a\x1c\x95\x50\x36\x0d\x07\xb5\x73\x7e\xb7\xd3\x1d\x71\x21\x1d\x24\x53\x2a\x86\x55\x31\x5e\x38\x5a\x57\xfc\x93\xff\xdf\xf9\x87\x64\xaa\x10\x6b\x2e\x05\x9c\x56\x21\x6d\xa8\x63\x89\x3d\x60\x49\x62\xb4\x18\x02\x36\xed\xc3\x6c\xb5\x3b\x22\x1d\xd5\x4e\x7a\x63\x59\x42\x0a\xe4\xbc\x1a\xff\xda\xdb\x6b\x4c\x56\xc7\x7a\xa9\x31\xf3\xa2\x64\x22\xce\xce\x0b\xca\xa3\x38\x70\xd1\x27\x1d\xdf\x6e\x6f\x82\xf2\x2d\x3b\x57\xbf\x27\x28\x0a\xc9\x20\x6d\xf3\x32\xdf\x32\x73\x46\xd6\x4a\xa1\x76\x8e\x69\x01\x53\x51\x88\x76\x6b\x70\x4b\x16\x24\x22\x51\xe9\x64\x67\x63\xba\xdf\xe8\xde\x81\xe0\x67\xc1\x37\x4e\x6c\x16\x35\x1b\x31\x5f\xcd\x52\x44\x9f\xac\x4e\x29\xcc\xc0\x61\x07\xbb\x92\xbf\xfa\x81\x2e\xa2\x7a\xa1\x0b\x13\x6b\x74\xfc\xa5\x8f\x77\xe0\x40\xa4\xcb\x5a\xa7\x79\xf9\xa0\x50\x64\x3b\x75\x25\x85\x31\x6e\x2c\x78\xa9\x4e\xd1\xcd\x6c\x6d\x23\x8b\x69\x69\x51\xfa\x66\x64\x86\xc7\xf6\x88\x29\x9f\xcb\x25\x3d\x93\xc4\xf1\x34\x4e\x5b\xf3\xe1\xc8\x94\xcc\xbf\x6b\xed\x52\x05\x30\xcb\x62\x1c\xbc\x9d\xd6\x4f\xc2\x1d\x3d\x4c\x3c\xfe\x07\x39\xa6\xfc\xa5\xae\xa6\xbf\xfa\x52\xbb\xee\x22\xf5\x18\x7c\xcb\x72\x97\xac\xa3\x65\x9c\x43\xf9\xe2\x3e\x81\xb3\x55\x0e\x4d\x20\x5c\xb6\xcc\x4f\xd0\x91\x61\x32\xe4\x7a\x35\xf1\x3d\x5e\x2d\x12\x34\x9f\x25\xa5\x3c\x02\x87\x81\xed\x0f\x78\xc4\xd9\x0a\xec\xb0\x47\x2b\x48\x49\x66\x43\x45\x42\xcd\x86\x5e\xd3\x41\xb9\x31\xd1\x70\x1f\x95\xbb\xd7\xa7\xbd\x1e\x8f\xef\xc3\x16\x9c\x3f\xd1\x38\xaa\xf8\x55\x18\xb3\x36\xc3\x33\x06\xec\x96\x49\x07\x67\x41\xd1\xab\xa6\xbe\x54\xeb\xac\xc7\x69\x14\x22\x62\x43\x29\x39\x83\x0d\x50\xb2\x50\xcf\xf0\xe1\xa6\x25\x80\x76\x49\xf8\x6d\xc1\x13\xac\xe1\xe7\x12\x06\x23\x65\xff\xae\x58\xa0\xd7\xc1\x16\xbb\x42\xe0\x6b\x8a\x08\x27\x58\x48\x1d\x41\xd5\xf4\xa0\xa5\x0e\x25\x31\x17\x0e\x4a\x65\x3d\xa8\xb6\xd4\x4b\x2f\x40\xb0\xd4\xf6\x5e\xf8\xba\x55\xc7\xc1\xaa\x22\x8c\x18\xad\x22\xbf\x0a\xd6\x62\x95\xed\xc9\xed\x5c\x12\xac\xe5\x93\xc2\x25\xef\x72\x44\xd1\x76\x62\x0f\xda\x04\x95\xa7\x10\x3b\xcf\xb7\x9a\x83\xf0\x94\xdf\xba\x79\x71\xd5\x6f\xd8\x08\x74\x2e\xa2\x99\xba\x66\x55\x20\xd8\xde\xae\x8d\xe7\x98\x56\x43\xd6\x92\xdc\x6d\x12\xe2\x2e\xf3\x93\x9a\x18\x57\x5e\x2a\x72\xe3\xf7\x76\x1a\x26\xf2\x9b\x51\x4e\x2e\x11\x0f\x46\xd2\x79\xfb\xe2\xdb\xbd\xa9\xe6\xe1\x24\xdd\x2f\x7f\xe1\xfb\x66\xcc\x1a\x6c\xed\xf7\xb8\x9f\x41\x9c\xd8\xeb\x93\x48\x31\x16\x24\x14\xee\x7b\xca\x67\x18\xb3\x14\x70\xbc\xdd\x0c\x56\x25\x4d\x19\x5f\x98\x81\xc1\xfa\x35\x23\x14\x80\xa1\xb4\xa3\x5c\x22\x63\x4c\xc0\x0d\x9e\x3b\x82\xbe\x56\x94\x25\xda\x7a\x71\x9d\x2a\x85\x9d\xab\x1c\xc9\x49\xc2\x29\x19\x87\x76\x0c\x65\x5b\xc5\x21\xc6\x68\xc2\x96\x5d\xdf\xab\x90\xc5\x98\x69\xa7\x52\x64\x51\x53\x21\x8a\xd8\xc2\x37\x8b\x6c\x70\x01\x8a\x75\x59\x34\x7d\xee\x16\x91\xc6\x84\x93\x08\xd4\xea\x81\x63\x48\x59\x8a\xb8\x41\x1b\x6c\x80";
		let public = b"\x01\x03\x00\x06\x10\xa6\x4b\x37\x7d\xb9\xba\x78\x61\x8f\xbf\xf9\x7e\x4f\x9c\xbc\xd4\xdd\x37\xf8\xca\xd5\x37\xc3\xcc\xd1\x50\xe8\xab\x05\x2c\x01\xf5\x60\xed\x58\x05\xb4\x5d\x2f\x67\xaa\xb0\x2d\x0f\x89\xda\x2f\x44\x40\x9a\x78\xe1\xb3\x35\x3f\xc1\xaf\xa7\xd7\x76\x12\xe7\xf7\xae\x2e\xee\x60\x2f\xba\x45\x7e\x38\x1b\x4d\xaa\xdc\x85\xab\x75\x2d\x2d\x2a\xe5\x8d\x5e\xe3\x16\x99\x23\x33\x06\x84\xfe\xaf\x63\xe3\x29\x6e\xfe\x8b\x1d\x89\x6c\x84\x2f\x8a\x36\xd8\x9f\x5d\xcf\xc9\x74\xe5\x4b\x5c\x2d\x4b\x7a\xea\x3b\x61\x84\x8a\xc5\xe1\xd9\x2b\x4a\xac\x16\x0a\x80\xf6\xac\x08\xdd\x1d\xa2\xc5\xed\x42\x5f\x89\x27\xae\xd9\x02\xee\x3a\xd9\x58\xbf\x53\xdb\x45\x6e\xc3\x58\x2d\x67\x36\xf1\xec\x1d\x06\xdd\x92\x43\x86\x5c\xa3\x61\xf1\xad\x1c\x07\xbe\xca\xb7\x7b\x7f\x31\x45\x1c\x84\x79\x68\xc5\x0c\x44\x97\x38\x5d\xe9\x7c\xbd\x6c\xcf\x5c\x02\xd9\xb2\x56\x43\xc1\xb9\x6c\x3d\x82\x31\xf4\xb7\x30\x61\x01\xdc\x67\x83\xde\x04\x37\x5e\x5a\x4c\x3a\xe4\x32\xba\x5d\x01\x18\x66\xc0\x1e\x62\xc7\x7e\x8c\x93\xa5\x65\xd3\xe7\xa9\x92\x90\x6e\xc7\xb9\x72\x13\xaa\xe8\x59\xf5\x26\x33\xca\x94\xe8\x0c\xff\xdb\x75\x41\x18\x04\xc6\xaa\x02\x48\x21\xce\x42\x3c\x2b\x6a\x66\x54\x05\x28\xa8\xba\xc5\xee\x7b\xe4\x19\x08\x43\x49\x9f\xa5\xd5\x5e\x5b\xc1\x57\xe5\x04\x62\x6e\x0f\x04\x0a\xea\x5a\x94\x7d\xcb\x7d\xf1\xb1\xfe\xab\x79\x85\x16\x82\x87\xc7\xf0\x1c\x59\xe5\x07\xeb\xc2\xa0\xa9\x01\xcd\x56\x06\x23\x1e\x7b\x94\xb7\x8b\x1f\x2b\x63\x4e\x01\xd8\x6c\x14\xfa\x9c\x32\xcc\x81\x02\xaa\x0f\xb5\x2e\x0b\x75\x92\x46\x02\x8e\xde\x5e\x9c\x12\x58\xf4\x78\xe0\xe9\xfb\xab\x0c\xcc\xc4\x9e\x20\x8b\xcc\xdc\xde\xbe\xb7\xa3\xed\x52\x7e\xae\x69\x69\x29\x34\x9e\xf0\x34\x9f\x5c\xa9\xa8\xd2\xc1\x94\x95\xde\x6b\xea\x9e\xb4\xcb\xc2\x49\xf1\x75\x12\x30\x84\x71\xa0\xe2\x66\x6c\xda\xe0\xc3\x52\x7a\xef\x6a\x1c\x95\x50\x36\x0d\x07\xb5\x73\x7e\xb7\xd3\x1d\x71\x21\x1d\x24\x53\x2a\x86\x55\x31\x5e\x38\x5a\x57\xfc\x93\xff\xdf\xf9\x87\x64\xaa\x10\x6b\x2e\x05\x9c\x56\x21\x6d\xa8\x63\x89\x3d\x60\x49\x62\xb4\x18\x02\x36\xed\xc3\x6c\xb5\x3b\x22\x1d\xd5\x4e\x7a\x63\x59\x42\x0a\xe4\xbc\x1a\xff\xda\xdb\x6b\x4c\x56\xc7\x7a\xa9\x31\xf3\xa2\x64\x22\xce\xce\x0b\xca\xa3\x38\x70\xd1\x27\x1d\xdf\x6e\x6f\x82\xf2\x2d\x3b\x57\xbf\x27\x28\x0a\xc9\x20\x6d\xf3\x32\xdf\x32\x73\x46\xd6\x4a\xa1\x76\x8e\x69\x01\x53\x51\x88\x76\x6b\x70\x4b\x16\x24\x22\x51\xe9\x64\x67\x63\xba\xdf\xe8\xde\x81\xe0\x67\xc1\x37\x4e\x6c\x16\x35\x1b\x31\x5f\xcd\x52\x44\x9f\xac\x4e\x29\xcc\xc0\x61\x07\xbb\x92\xbf\xfa\x81\x2e\xa2\x7a\xa1\x0b\x13\x6b\x74\xfc\xa5\x8f\x77\xe0\x40\xa4\xcb\x5a\xa7\x79\xf9\xa0\x50\x64\x3b\x75\x25\x85\x31\x6e\x2c\x78\xa9\x4e\xd1\xcd\x6c\x6d\x23\x8b\x69\x69\x51\xfa\x66\x64\x86\xc7\xf6\x88\x29\x9f\xcb\x25\x3d\x93\xc4\xf1\x34\x4e\x5b\xf3\xe1\xc8\x94\xcc\xbf\x6b\xed\x52\x05\x30\xcb\x62\x1c\xbc\x9d\xd6\x4f\xc2\x1d\x3d\x4c\x3c\xfe\x07\x39\xa6\xfc\xa5\xae\xa6\xbf\xfa\x52\xbb\xee\x22\xf5\x18\x7c\xcb\x72\x97\xac\xa3\x65\x9c\x43\xf9\xe2\x3e\x81\xb3\x55\x0e\x4d\x20\x5c\xb6\xcc\x4f\xd0\x91\x61\x32\xe4\x7a\x35\xf1\x3d\x5e\x2d\x12\x34\x9f\x25\xa5\x3c\x02\x87\x81\xed\x0f\x78\xc4\xd9\x0a\xec\xb0\x47\x2b\x48\x49\x66\x43\x45\x42\xcd\x86\x5e\xd3\x41\xb9\x31\xd1\x70\x1f\x95\xbb\xd7\xa7\xbd\x1e\x8f\xef\xc3\x16\x9c\x3f\xd1\x38\xaa\xf8\x55\x18\xb3\x36\xc3\x33\x06\xec\x96\x49\x07\x67\x41\xd1\xab\xa6\xbe\x54\xeb\xac\xc7\x69\x14\x22\x62\x43\x29\x39\x83\x0d\x50\xb2\x50\xcf\xf0\xe1\xa6\x25\x80\x76\x49\xf8\x6d\xc1\x13\xac\xe1\xe7\x12\x06\x23\x65\xff\xae\x58\xa0\xd7\xc1\x16\xbb\x42\xe0\x6b\x8a\x08\x27\x58\x48\x1d\x41\xd5\xf4\xa0\xa5\x0e\x25\x31\x17\x0e\x4a\x65\x3d\xa8\xb6\xd4\x4b\x2f\x40\xb0\xd4\xf6\x5e\xf8\xba\x55\xc7\xc1\xaa\x22\x8c\x18\xad\x22\xbf\x0a\xd6\x62\x95\xed\xc9\xed\x5c\x12\xac\xe5\x93\xc2\x25\xef\x72\x44\xd1\x76\x62\x0f\xda\x04\x95\xa7\x10\x3b\xcf\xb7\x9a\x83\xf0\x94\xdf\xba\x79\x71\xd5\x6f\xd8\x08\x74\x2e\xa2\x99\xba\x66\x55\x20\xd8\xde\xae\x8d\xe7\x98\x56\x43\xd6\x92\xdc\x6d\x12\xe2\x2e\xf3\x93\x9a\x18\x57\x5e\x2a\x72\xe3\xf7\x76\x1a\x26\xf2\x9b\x51\x4e\x2e\x11\x0f\x46\xd2\x79\xfb\xe2\xdb\xbd\xa9\xe6\xe1\x24\xdd\x2f\x7f\xe1\xfb\x66\xcc\x1a\x6c\xed\xf7\xb8\x9f\x41\x9c\xd8\xeb\x93\x48\x31\x16\x24\x14\xee\x7b\xca\x67\x18\xb3\x14\x70\xbc\xdd\x0c\x56\x25\x4d\x19\x5f\x98";

		KeyPairNtru::new(private.into(), public.into())
	}

	fn bob_x448_identity() -> KeyPairX448 {
		let private = b"\x80\x5a\xda\x93\x59\xcb\xa7\x6b\x7f\xeb\x4e\x08\x56\xc8\xd7\x7e\x00\x29\x96\x0b\x7c\xa9\xe1\x1a\x0e\x7b\x98\x0a\xc8\x0b\x6e\xbb\xa3\xde\x00\xfb\x7a\xf9\xdc\xab\xa6\x2d\x63\x58\xc5\xc1\x79\xf7\x90\x26\x76\x17\x87\xcb\x21\xb2";
		let public = b"\xc0\x48\x15\x74\x0d\xe0\xf7\xf2\x57\x0b\x62\xae\x04\x41\x8d\xf7\xa8\x71\x78\x77\xec\x1f\x89\xeb\x86\x50\x69\xe4\x15\xc2\x81\x04\x95\xd6\x3f\x6a\x17\x96\x7d\xb6\x35\x4a\xb6\x8c\x38\xb2\x3b\xfd\x92\x12\x05\xba\xda\x32\xf2\x29";

		KeyPairX448::new(private.into(), public.into())
	}

	fn bob_x448_prekey() -> KeyPairX448 {
		let private = b"\x98\x96\xd4\x72\xf4\x4b\x46\x18\xa6\x33\x24\xf6\x7f\x94\x77\x48\xd7\x88\x0f\x1b\xdb\xf8\x56\x75\x2c\x0b\x4f\xa5\xeb\x4a\xca\xd2\x00\x06\x3b\x72\x7b\xe3\x3e\xfd\xb8\x32\x73\xc1\x1f\x9e\xcd\xdc\x90\xfe\x60\xb1\x88\x55\x3a\xb8";
		let public = b"\xfd\x36\xa7\x7e\x1c\xe5\x3a\x60\x34\x8b\x66\x79\xeb\xa6\x61\x27\x40\x0e\x05\x2d\x90\x7e\x5e\x0b\xbf\xe6\x0c\x13\x71\x9d\x66\xf7\x83\xd2\x4b\x8f\x5e\x8d\x15\x66\xf7\x02\xa4\xad\x28\x9d\x9c\x29\x14\xde\x33\x2b\xc6\xb7\x68\xe3";

		KeyPairX448::new(private.into(), public.into())
	}

	fn bob_ed448_identity() -> KeyPairEd448 {
		let private = b"\x43\x00\xdc\xee\x83\xb7\xc5\xdd\x43\x28\x8a\xb6\x3e\xd4\xd0\xaa\xb0\x4a\x97\xc0\x90\xfa\x68\x05\x49\x12\x46\x5b\x5f\x4a\xc6\xde\x34\x32\xb8\x57\x74\xa6\xce\x6c\x9c\x9d\x2e\xc0\xbd\x50\x1d\xdf\x50\xbe\x28\xb9\x82\xf0\x33\x0e\xc7";
		let public = b"\x4b\xee\xf9\x7d\x50\x95\xb7\x8d\x59\x75\xe0\xfe\x9c\xbb\x2c\xcc\xa5\x47\x1f\x67\x68\xc8\x03\xdd\xfc\x18\x67\x95\xad\xe7\x07\x9c\x38\x9f\xa4\x7a\xac\x20\x85\x79\x5a\xfb\xb7\xe2\x9b\x24\xa0\x7b\xe1\xec\x2c\x5e\xf2\xa0\xaf\x9d\x80";

		KeyPairEd448::new(private.into(), public.into())
	}

	fn bob_ntru_identity() -> KeyPairNtru {
		let private = b"\x02\x03\x00\x06\x10\xe1\xa6\x4e\xb5\x51\x74\x63\xca\x31\xbc\x0b\x69\x52\xc7\x81\x76\x1f\xe8\x44\xcb\xfb\x4c\x32\xfb\x67\x4e\x92\xe3\xe0\x0b\xdd\x90\x46\xb1\x35\xb0\x6f\x31\x2c\x2b\x2c\xe4\x9b\x52\xb4\x09\xee\x2e\x67\x9d\x32\xbc\xb0\x3e\x0a\xd5\x63\xd4\x3a\x0d\x70\x3c\x80\x54\xb7\x7f\xa0\xe7\x9b\x5e\xe4\xb1\x53\x31\xc9\x4b\xf8\x92\x0a\x0d\x89\x46\xd7\xd1\xe0\x23\xa9\x5f\x21\xc0\x8f\xce\x69\x9a\xd6\x80\xbf\x5f\x2e\x6e\x63\x2b\xf6\x46\x3d\x6f\xd2\x48\x3e\x98\x28\xf5\xca\x7e\x80\x93\x4a\x15\x03\xaf\xe9\x2e\xe3\xda\x4c\x6f\x83\x07\xd9\xea\xbe\x05\x8d\x54\xe7\xa8\x06\x20\x36\xf5\xa0\x18\x4f\x00\xe2\x6f\xe7\x07\x51\x95\xd8\x54\x77\x81\x3d\xa3\xa0\x29\x03\x8e\x67\xd3\xcd\x3f\x16\xc5\xff\xab\x41\x25\xc8\x9a\x2a\x55\x40\x6b\xa6\x9e\xce\xe5\xdd\xa1\x3c\x60\x3d\x5c\x38\x8e\x31\x68\x7a\x9c\xd8\x82\x46\x2b\xe3\x12\x03\x53\x94\x88\xbd\x56\x66\xca\x37\x48\x8d\xae\x99\xd7\xa4\xe3\xd5\x8e\xec\x9b\xe7\x04\x27\x2f\xb4\x84\xe0\xaa\xe0\x54\xf7\xaa\x6a\x1c\x96\xcf\x50\xad\x5b\xe1\x4e\x3a\xb3\xa6\x9a\xdc\x32\x32\x7a\x4b\x6e\xf6\xc1\xa9\xde\x42\x80\x44\xdb\x8d\x0e\xba\x0a\x2e\xc0\x7e\x40\x34\xe1\x79\x1c\x7d\xc9\xeb\xa6\x0c\x3b\x51\xf2\x24\x9c\x17\xdb\x47\x97\x4e\x6e\x10\x84\x81\x6e\xed\x26\xb5\x86\xc4\x80\x6e\x97\xe9\xaa\x26\x68\xfd\xb2\xe8\x50\x50\x71\xa2\x16\x21\x48\xf2\xab\xfb\x62\x51\x2f\xef\x28\xab\x5d\xd2\xde\xd7\xb7\x41\x85\x35\x25\x6a\xe2\x64\x7c\x6e\xd1\xe6\x70\x06\xdb\x35\x7b\xbb\xdd\x36\x0c\x4e\xb0\x66\xa3\x74\xbb\xb4\x2f\x02\x2f\x91\x9e\xce\x4d\x13\xfc\xc0\xb9\x1b\x94\x6f\x0a\x58\x46\xd7\xab\x56\x0f\x84\xa8\x76\x8f\x0f\x6c\xf0\x32\x78\x4b\x18\x16\x04\x87\x5d\x19\x63\x4c\x5a\x6e\xe4\x9e\x74\x17\xf9\xd2\x2e\xd1\xf4\x92\x59\x9c\xaf\xaa\x12\x97\x1c\x3e\xf5\xc9\x27\x56\xa3\x96\xef\xe0\x1a\x6f\x91\x71\xdf\xab\x2b\x2c\xd9\xdd\x16\x49\x2b\x1b\x78\xfb\x60\x7d\x64\xcf\x1c\x88\x56\x23\xd4\xc0\x6a\x6d\x3e\x7a\x64\x79\xcb\xd9\xf9\xfe\xc6\x2f\xa2\x91\xbf\x68\xd1\xa0\x7e\x88\xb3\xe2\x36\x3c\x8f\x54\xe9\xea\x32\x2f\xe6\x56\x92\x85\x61\x75\xcf\x64\x67\x20\x26\x48\x77\xf8\x5b\x64\x58\x0a\x4a\xe2\x2f\x8a\x6b\x23\x57\xd6\x0f\x37\x12\xa7\x6d\x42\x4d\x94\xb0\x68\xa7\x42\xc4\x65\xe1\x30\x44\xb9\xab\xb8\x67\x3c\x42\x18\x4d\xbd\x4b\x24\xd8\xe8\x37\x87\x84\x05\xf0\xf9\xc9\x4a\x20\x31\x46\x89\x8b\x16\x93\x29\x32\x90\xf4\xd6\x9d\xe0\x40\x79\x6d\x4a\x6f\xc7\x01\xcd\x72\xc9\x83\xc1\x23\x73\x8b\xea\x4c\x3d\xe1\xe2\x93\x02\xe2\x0c\x3b\xd9\x0f\xb6\xc3\x42\xb4\x8f\x39\xf9\xb7\x4f\x0d\xc8\xb9\xa1\xbd\xde\x84\x80\x68\xe6\xc3\x21\x0c\x74\x42\xce\x6d\x76\x5b\xe0\x5d\x29\x8c\xb8\xfe\x31\x01\x4a\x70\x37\x93\xb1\x5c\xc4\xe8\x17\x36\x32\x6b\xd5\x34\x94\xa4\x58\x5c\x96\xd2\x76\x6f\x5f\x55\x55\x41\x68\x0b\x1b\x5e\xde\xa1\xc5\x09\x73\x98\x5d\xc3\x6d\x8a\x9b\x33\xd2\xf1\xf3\x52\x3b\x38\xb5\x19\xeb\xe6\x5d\xc4\xc3\x96\x01\x1e\x93\x8d\x02\x55\x80\x9e\x2f\x82\xeb\xac\xa2\x76\x4b\x06\x00\xdf\xda\xe6\x77\xe0\x35\x73\x45\xd8\x40\xc2\xd1\x42\xa7\x31\xff\x2b\xac\x78\xee\x88\x5f\x7d\x86\xe1\xd0\xba\x49\x5a\x96\xe8\x4a\xcc\xab\x9e\x85\x52\x27\x6f\x15\x34\x00\x1c\x63\x42\x52\x7e\xf8\x4f\xfb\x62\x8d\x46\xd7\x5d\xd6\xcb\x48\xdc\x18\xcb\xb0\xba\x2f\xed\xa3\xbc\x8e\xc0\xda\x1e\xd0\x7e\xf8\x82\x5f\x82\x6d\x1c\xe6\x25\x55\xbb\x12\xc4\xc6\x57\x0b\xf6\xf4\xc5\x04\x91\x6a\xf3\x25\x57\x57\x9d\x56\x97\x84\x03\x96\xf6\x19\x3b\x7e\x13\xb4\xef\x8a\xfd\x57\xf4\x64\xf1\x74\x6c\x0d\x96\xa7\x37\xe7\x50\x2a\x5c\xe3\x4a\x8e\xc9\x26\xc8\xb9\x1a\x9b\xa4\x61\x3f\x73\x94\x55\xc9\xc1\x1f\xf6\x7f\x75\x30\x75\xd3\x1a\x04\x3f\x33\xd1\x74\x18\x78\xa4\x86\xe9\x09\xa5\x24\xa7\x98\xe9\x25\x68\x03\x68\xa2\x98\x80\x6a\x4a\x46\xa5\xd7\xe9\x52\x41\x94\x3e\xaf\xd0\xa4\x1e\x8d\xdd\x8c\x1d\x5b\xfb\xc1\xc6\x45\x0f\x57\x21\xba\xf2\x54\xe0\x64\x8c\xbc\x50\xe4\xdd\x13\x65\xcb\xae\x5e\xa5\xe7\x8a\xca\xc7\x89\xd9\x61\xbd\x28\x9e\x3f\xd4\xde\xba\x82\x6d\x80\x73\xd4\x71\xe4\xbd\x55\x06\x48\x82\x3b\x3f\xb0\x1d\x2a\xb7\x78\xc4\x42\xf3\xd0\xe1\x2b\x0d\x43\x74\xac\x58\xf4\x92\xf0\x14\x67\x61\x06\x58\x7f\xd6\x98\x62\xd7\x82\x09\xf6\x52\xa8\x17\x02\x5f\xd9\x40\xa2\x8d\x04\x33\x0a\xc9\x5d\xde\x31\xef\xe0\xfe\x91\x63\x90\xfb\xb6\x4f\x35\x5f\xf5\xd3\x4b\xf7\xa8\x34\x9d\x22\x66\x54\x28\xdc\x32\x5e\x8b\x23\x2a\x34\x05\x84\x62\x08\xe2\x90\x64\x91\x0d\x96\x88\xb6\x5a\x4b\x6e\x34\x82\x1a\x82\x4c\x97\x21\x40\x98\x74\x04\x03\x1e\x47\xec\x4b\x3d\xc6\xa6\x31\x24\x42\xec\x48\x41\x14\x3e\x40\x0b\x6c\x66\x4e\x97\xb4\xd4\x2c\x8a\x2d\xf6\x4e\x46\xa4\xa9\x32\xde\x89\x1e\x49\x69\x15\x96\x2a\xc2\xe1\xb5\xb3\x66\xd3\x58\x09\xc8\x26\x63\xd6\x69\x30\x0c\x86\xe9\x4a\x94\x97\x5f\x20\xd4\xdf\x73\x09\x32\x5c\xc3\x97\x07\x0b\x34\x83\x05\xcd\x30";
		let public = b"\x01\x03\x00\x06\x10\xe1\xa6\x4e\xb5\x51\x74\x63\xca\x31\xbc\x0b\x69\x52\xc7\x81\x76\x1f\xe8\x44\xcb\xfb\x4c\x32\xfb\x67\x4e\x92\xe3\xe0\x0b\xdd\x90\x46\xb1\x35\xb0\x6f\x31\x2c\x2b\x2c\xe4\x9b\x52\xb4\x09\xee\x2e\x67\x9d\x32\xbc\xb0\x3e\x0a\xd5\x63\xd4\x3a\x0d\x70\x3c\x80\x54\xb7\x7f\xa0\xe7\x9b\x5e\xe4\xb1\x53\x31\xc9\x4b\xf8\x92\x0a\x0d\x89\x46\xd7\xd1\xe0\x23\xa9\x5f\x21\xc0\x8f\xce\x69\x9a\xd6\x80\xbf\x5f\x2e\x6e\x63\x2b\xf6\x46\x3d\x6f\xd2\x48\x3e\x98\x28\xf5\xca\x7e\x80\x93\x4a\x15\x03\xaf\xe9\x2e\xe3\xda\x4c\x6f\x83\x07\xd9\xea\xbe\x05\x8d\x54\xe7\xa8\x06\x20\x36\xf5\xa0\x18\x4f\x00\xe2\x6f\xe7\x07\x51\x95\xd8\x54\x77\x81\x3d\xa3\xa0\x29\x03\x8e\x67\xd3\xcd\x3f\x16\xc5\xff\xab\x41\x25\xc8\x9a\x2a\x55\x40\x6b\xa6\x9e\xce\xe5\xdd\xa1\x3c\x60\x3d\x5c\x38\x8e\x31\x68\x7a\x9c\xd8\x82\x46\x2b\xe3\x12\x03\x53\x94\x88\xbd\x56\x66\xca\x37\x48\x8d\xae\x99\xd7\xa4\xe3\xd5\x8e\xec\x9b\xe7\x04\x27\x2f\xb4\x84\xe0\xaa\xe0\x54\xf7\xaa\x6a\x1c\x96\xcf\x50\xad\x5b\xe1\x4e\x3a\xb3\xa6\x9a\xdc\x32\x32\x7a\x4b\x6e\xf6\xc1\xa9\xde\x42\x80\x44\xdb\x8d\x0e\xba\x0a\x2e\xc0\x7e\x40\x34\xe1\x79\x1c\x7d\xc9\xeb\xa6\x0c\x3b\x51\xf2\x24\x9c\x17\xdb\x47\x97\x4e\x6e\x10\x84\x81\x6e\xed\x26\xb5\x86\xc4\x80\x6e\x97\xe9\xaa\x26\x68\xfd\xb2\xe8\x50\x50\x71\xa2\x16\x21\x48\xf2\xab\xfb\x62\x51\x2f\xef\x28\xab\x5d\xd2\xde\xd7\xb7\x41\x85\x35\x25\x6a\xe2\x64\x7c\x6e\xd1\xe6\x70\x06\xdb\x35\x7b\xbb\xdd\x36\x0c\x4e\xb0\x66\xa3\x74\xbb\xb4\x2f\x02\x2f\x91\x9e\xce\x4d\x13\xfc\xc0\xb9\x1b\x94\x6f\x0a\x58\x46\xd7\xab\x56\x0f\x84\xa8\x76\x8f\x0f\x6c\xf0\x32\x78\x4b\x18\x16\x04\x87\x5d\x19\x63\x4c\x5a\x6e\xe4\x9e\x74\x17\xf9\xd2\x2e\xd1\xf4\x92\x59\x9c\xaf\xaa\x12\x97\x1c\x3e\xf5\xc9\x27\x56\xa3\x96\xef\xe0\x1a\x6f\x91\x71\xdf\xab\x2b\x2c\xd9\xdd\x16\x49\x2b\x1b\x78\xfb\x60\x7d\x64\xcf\x1c\x88\x56\x23\xd4\xc0\x6a\x6d\x3e\x7a\x64\x79\xcb\xd9\xf9\xfe\xc6\x2f\xa2\x91\xbf\x68\xd1\xa0\x7e\x88\xb3\xe2\x36\x3c\x8f\x54\xe9\xea\x32\x2f\xe6\x56\x92\x85\x61\x75\xcf\x64\x67\x20\x26\x48\x77\xf8\x5b\x64\x58\x0a\x4a\xe2\x2f\x8a\x6b\x23\x57\xd6\x0f\x37\x12\xa7\x6d\x42\x4d\x94\xb0\x68\xa7\x42\xc4\x65\xe1\x30\x44\xb9\xab\xb8\x67\x3c\x42\x18\x4d\xbd\x4b\x24\xd8\xe8\x37\x87\x84\x05\xf0\xf9\xc9\x4a\x20\x31\x46\x89\x8b\x16\x93\x29\x32\x90\xf4\xd6\x9d\xe0\x40\x79\x6d\x4a\x6f\xc7\x01\xcd\x72\xc9\x83\xc1\x23\x73\x8b\xea\x4c\x3d\xe1\xe2\x93\x02\xe2\x0c\x3b\xd9\x0f\xb6\xc3\x42\xb4\x8f\x39\xf9\xb7\x4f\x0d\xc8\xb9\xa1\xbd\xde\x84\x80\x68\xe6\xc3\x21\x0c\x74\x42\xce\x6d\x76\x5b\xe0\x5d\x29\x8c\xb8\xfe\x31\x01\x4a\x70\x37\x93\xb1\x5c\xc4\xe8\x17\x36\x32\x6b\xd5\x34\x94\xa4\x58\x5c\x96\xd2\x76\x6f\x5f\x55\x55\x41\x68\x0b\x1b\x5e\xde\xa1\xc5\x09\x73\x98\x5d\xc3\x6d\x8a\x9b\x33\xd2\xf1\xf3\x52\x3b\x38\xb5\x19\xeb\xe6\x5d\xc4\xc3\x96\x01\x1e\x93\x8d\x02\x55\x80\x9e\x2f\x82\xeb\xac\xa2\x76\x4b\x06\x00\xdf\xda\xe6\x77\xe0\x35\x73\x45\xd8\x40\xc2\xd1\x42\xa7\x31\xff\x2b\xac\x78\xee\x88\x5f\x7d\x86\xe1\xd0\xba\x49\x5a\x96\xe8\x4a\xcc\xab\x9e\x85\x52\x27\x6f\x15\x34\x00\x1c\x63\x42\x52\x7e\xf8\x4f\xfb\x62\x8d\x46\xd7\x5d\xd6\xcb\x48\xdc\x18\xcb\xb0\xba\x2f\xed\xa3\xbc\x8e\xc0\xda\x1e\xd0\x7e\xf8\x82\x5f\x82\x6d\x1c\xe6\x25\x55\xbb\x12\xc4\xc6\x57\x0b\xf6\xf4\xc5\x04\x91\x6a\xf3\x25\x57\x57\x9d\x56\x97\x84\x03\x96\xf6\x19\x3b\x7e\x13\xb4\xef\x8a\xfd\x57\xf4\x64\xf1\x74\x6c\x0d\x96\xa7\x37\xe7\x50\x2a\x5c\xe3\x4a\x8e\xc9\x26\xc8\xb9\x1a\x9b\xa4\x61\x3f\x73\x94\x55\xc9\xc1\x1f\xf6\x7f\x75\x30\x75\xd3\x1a\x04\x3f\x33\xd1\x74\x18\x78\xa4\x86\xe9\x09\xa5\x24\xa7\x98\xe9\x25\x68\x03\x68\xa2\x98\x80\x6a\x4a\x46\xa5\xd7\xe9\x52\x41\x94\x3e\xaf\xd0\xa4\x1e\x8d\xdd\x8c\x1d\x5b\xfb\xc1\xc6\x45\x0f\x57\x21\xba\xf2\x54\xe0\x64\x8c\xbc\x50\xe4\xdd\x13\x65\xcb\xae\x5e\xa5\xe7\x8a\xca\xc7\x89\xd9\x61\xbd\x28\x9e\x3f\xd4\xde\xba\x82\x6d\x80\x73\xd4\x71\xe4\xbd\x55\x06\x48\x82\x3b\x3f\xb0\x1d\x2a\xb7\x78\xc4\x42\xf3\xd0\xe1\x2b\x0d\x43\x74\xac\x58\xf4\x92\xf0\x14\x67\x61\x06\x58\x7f\xd6\x98\x62\xd7\x82\x09\xf6\x52\xa8\x17\x02\x5f\xd9\x40\xa2\x8d\x04\x33\x0a\xc9\x5d\xde\x31\xef\xe0\xfe\x91\x63\x90\xfb\xb6\x4f\x35\x5f\xf5\xd3\x4b\xf7\xa8\x34\x9d\x22\x66\x54\x28\xdc\x32\x5e\x8b\x23\x2a\x34\x05\x84\x62\x08\xe2\x90\x64\x91\x0d\x96\x88";

		KeyPairNtru::new(private.into(), public.into())
	}

	fn bob_ntru_prekey() -> KeyPairNtru {
		let private = b"\x02\x03\x00\x06\x10\x24\x3e\x65\x0a\xb8\xd4\xfc\xff\x9b\x24\x1a\x03\xc0\x0c\xda\x44\xaf\xf2\x97\x97\x6d\x0b\xb4\x3d\xad\x39\x0b\x8f\x32\x9c\xd5\x30\xe1\xc9\xf9\x3b\xcc\x69\x3c\xe9\xa0\xe6\x29\xc7\x77\xff\x7f\x6b\xcc\x78\xb6\xfd\x88\x5e\x78\x72\xfd\xd2\x40\x96\x33\x07\xe6\x6c\xab\xbe\x4c\x6b\xa5\x31\x15\x42\x8a\x9b\x8c\x89\x90\x6e\xda\x41\x73\x1d\xea\x1b\x99\x0f\x88\x8f\x88\x9e\x46\x1c\xca\x67\x13\xb5\xa8\x2b\x69\x2c\xa8\x90\xdc\x90\x1b\xbc\x63\x29\x44\xf4\x7a\x09\x75\x28\x14\x70\x35\x12\x50\xfc\xf5\x45\xfe\x36\xa1\xa8\x0f\x60\x46\x96\xc7\x98\xea\xad\x64\x5b\xa6\x1d\x81\xd1\xfa\x41\x1d\x2c\xcf\xad\xcc\x46\x64\xdd\xc3\x06\xf3\x67\x33\x40\xe0\xb7\x50\x26\x28\xb3\x23\x0e\x63\x62\xc3\x54\x2d\xc0\xa7\x0f\x5e\x02\x81\xc9\x03\x66\x3f\xab\x97\x09\x0e\x1f\x04\x8e\x9c\xce\x91\xa4\x24\x8b\xd2\xd6\x51\x7f\xbd\x6a\x30\x27\xd9\x80\x63\x81\xcc\x26\x57\x98\xa0\xc1\xac\xd1\x74\xd4\xa0\x52\xe1\xc2\x8e\x89\xa1\xf1\xee\x4a\x91\x6f\xed\x01\x79\x6e\x3a\x75\x29\xaf\x7b\x0e\x81\xdc\x0a\x69\xb8\xd7\x2a\x05\xf4\x02\xef\x8a\x83\x37\xd8\x58\xc5\xee\xd6\x85\x4f\x91\xa9\xb9\xdd\x9b\x84\x83\xf6\x4b\x21\x46\x80\x9d\x19\x11\x2a\x71\x91\x5a\xe4\x45\xb6\xcc\xda\xc2\xa2\xe4\x4c\x85\xb6\x3f\x1e\xf2\x2e\xfb\x5a\x1a\x23\x0b\xc0\x7b\x11\x9d\x4b\xbe\xe6\xa5\xe2\xf8\xcc\x2d\x5e\x7f\x32\x4f\x60\x2a\x5e\x52\x53\x20\x6b\x4e\x5a\xd6\xef\x95\xc7\x13\x29\x5d\x0d\x19\xa6\x08\xd9\x07\x1e\x6f\x0c\x4c\xb9\x81\x11\xba\x65\x1d\xd8\x94\x54\x0e\x84\xc2\x7a\x84\x08\x4b\xbc\x0d\x31\x78\x39\x72\x7c\x5a\x89\xcb\x6e\xf4\x9e\x42\x90\x7b\x48\x6d\xa0\x8f\x14\xc2\x72\xe7\x64\x35\xff\x87\x9c\xd4\x80\x40\x80\x1a\xcc\x90\x87\x97\xd4\x6e\xf2\xdd\xf3\xaa\x09\x52\x0a\xf9\x91\x46\xae\x97\xdc\x81\xde\xaa\x47\x47\xdc\x9d\xdb\x43\x85\x6d\x40\xe1\x9c\x9d\x62\xe8\x2d\x0f\x11\x7d\x9c\x7d\xa0\xfb\x01\xdf\x39\x74\x0e\x98\xf1\x95\xd7\xdc\xa4\xe5\x6d\x3d\x10\x25\xfc\x2b\x90\x5f\x77\xea\xbb\xda\xea\x7e\x9d\x29\x2c\x43\xd8\x0f\xb9\x34\x4e\x6a\x7e\x02\xea\xe9\x91\x56\x70\x96\x6f\xd0\x3d\xe7\xdc\xe0\xdd\x62\x77\x30\x2a\x3e\xf1\x9e\xb6\x74\xcc\x77\xea\x49\x64\xd6\x94\x24\x97\xae\x54\x8f\x1d\x45\x49\x87\xe0\x27\x5b\x73\xf3\x38\xcc\xdd\x58\x2d\xcd\x1c\x7e\x05\x16\xe2\xb8\x4c\xdf\xcc\x35\xc9\x3e\xc2\x96\x2f\x81\x63\x05\xdd\x63\xfb\xbd\xf2\x47\x10\x63\x2c\x69\xc4\xdb\x80\x09\xe6\x0b\x22\x3f\x38\x09\x75\xde\x6d\x6e\xb9\xcc\x20\xbb\x6e\x42\xa4\x10\x47\xa7\x06\xd6\x23\x37\xc0\xe6\x08\x61\xad\x59\x5b\x5c\x08\x3d\x84\x22\x36\x1d\xe6\x62\x5e\x02\x40\x78\x7d\x72\xde\xcb\x8e\x60\x70\x3d\x0a\xf0\x20\x83\xb8\xe1\x0e\x61\x70\x42\xa2\x5f\xf9\xd9\xe0\x32\xa6\x15\xc1\xa4\x5e\x7a\x73\x1b\x99\x1a\x66\x99\x0a\x10\x2c\x2c\x64\xc3\x4f\x63\xc3\xb8\x7d\x51\xcc\x21\x95\xc6\x2a\xd9\xc7\xad\x77\xee\xa5\xed\x46\xbe\xe9\x4e\x2a\xac\x77\x9a\x1c\x85\x3c\x5f\x38\x6a\xa8\x4b\x81\xe1\x26\x43\x26\xf3\x70\x47\x48\x41\x18\xef\x1a\xde\xaa\x2b\x63\xba\x28\xa3\x8d\x8b\xda\xaa\x07\xfb\x8b\x7b\x81\x1a\x58\xce\xe7\x6c\xa3\xe9\x53\xbb\x40\x2d\x03\x82\x26\x46\x5e\xb4\x2e\xe5\x65\x78\xb5\x8b\x6e\x01\x7d\x84\x63\xd8\x70\x86\x7e\x19\xdb\x4d\x37\xc3\xce\x18\x54\xaa\x0e\x1b\x42\xf7\x85\x8e\x9c\x1e\x56\x1f\x10\x96\xda\xe1\xef\x0e\xd9\x10\x09\xf8\x76\x99\x51\x63\x1d\x7a\x73\x4d\x7e\xb7\x06\x92\x61\xe9\x3c\xaa\x7f\x8f\x09\x42\x2a\xbb\xa5\x17\xaf\x2b\xe1\x38\x59\xf1\xe7\x86\xde\x55\xca\xd9\xab\x80\xc5\xe5\x06\xb2\xbb\x89\xe2\xaa\x21\x8d\x20\xdc\x4c\x6a\x96\xe0\x78\x22\x83\x96\x2b\xe1\x94\x94\x62\xd0\x75\x4c\x60\xd4\x4d\x53\x2c\xd7\x76\x1b\x7a\x23\xe5\xa3\x8f\xbd\x0d\x3e\x0b\x47\x2d\xd0\x8b\x09\x8a\x14\x9c\xfc\x8a\x13\xc7\x98\x5d\xd7\x9b\x5c\xb5\xef\x22\xfa\x92\xa2\xc3\xf1\x9f\x96\x08\x3b\xbc\x0d\x1b\x12\x1f\xd7\x7c\x03\x10\x87\x27\x98\xd6\x1f\xac\x5b\x17\xcf\x4f\xc2\x06\x8e\x13\xb9\x94\x06\x02\x3f\x7b\xa6\x29\x50\xb1\xc5\x65\x8a\x3c\x7a\xe3\xa1\xa3\x33\x79\xc3\x90\x5b\xf9\x19\x77\xc7\x06\xb7\xc4\x2a\x26\x4e\x69\x35\xd7\xbb\x30\xd6\x54\x81\x8e\x29\x0b\x01\x56\x73\xba\x5f\x5f\x9f\x9f\xd8\x7e\x8c\x8e\xc0\x05\xe6\x44\x27\x1b\x1f\x28\xa1\x6f\x0e\x27\x5d\x1d\xdc\xd5\xa2\x40\xf1\xf2\x4e\xb9\x65\x77\xcd\xc1\x7d\xa2\x7d\x4a\xdc\x58\x41\x09\x43\x65\x56\xf7\x42\x02\xd9\x90\x21\xd8\x51\x4a\x49\x2b\x2b\xd3\x79\x47\x53\xf7\x8d\xc3\x07\xe7\x08\x25\x8c\x9e\xc0\xd8\xa4\x6c\x94\x59\x50\x60\x7e\xdd\xb9\x56\xb4\x82\x82\xa3\x32\xd5\x1f\x96\x38\x2e\x56\x05\x53\x72\x41\x73\x04\xa5\x7b\x42\x2e\x48\x5e\x47\xc2\x8e\x2e\x6d\xa9\xc8\xb0\x99\xec\xc1\xb1\x2f\xa9\xac\x28\xb0\x5f\x44\x6d\x90\x16\x96\x36\xdf\xe4\x71\xa7\x47\xe7\xb6\x59\xbf\x6c\x28\x45\xc6\x0b\x5b\x22\xba\x05\x4b\xa1\x66\x99\x8a\x01\x97\x55\xe0\x4d\x58\x40\x97\xf4\x32\xe0\x92\x96\xeb\x61\x8c\x61\x19\x70";
		let public = b"\x01\x03\x00\x06\x10\x24\x3e\x65\x0a\xb8\xd4\xfc\xff\x9b\x24\x1a\x03\xc0\x0c\xda\x44\xaf\xf2\x97\x97\x6d\x0b\xb4\x3d\xad\x39\x0b\x8f\x32\x9c\xd5\x30\xe1\xc9\xf9\x3b\xcc\x69\x3c\xe9\xa0\xe6\x29\xc7\x77\xff\x7f\x6b\xcc\x78\xb6\xfd\x88\x5e\x78\x72\xfd\xd2\x40\x96\x33\x07\xe6\x6c\xab\xbe\x4c\x6b\xa5\x31\x15\x42\x8a\x9b\x8c\x89\x90\x6e\xda\x41\x73\x1d\xea\x1b\x99\x0f\x88\x8f\x88\x9e\x46\x1c\xca\x67\x13\xb5\xa8\x2b\x69\x2c\xa8\x90\xdc\x90\x1b\xbc\x63\x29\x44\xf4\x7a\x09\x75\x28\x14\x70\x35\x12\x50\xfc\xf5\x45\xfe\x36\xa1\xa8\x0f\x60\x46\x96\xc7\x98\xea\xad\x64\x5b\xa6\x1d\x81\xd1\xfa\x41\x1d\x2c\xcf\xad\xcc\x46\x64\xdd\xc3\x06\xf3\x67\x33\x40\xe0\xb7\x50\x26\x28\xb3\x23\x0e\x63\x62\xc3\x54\x2d\xc0\xa7\x0f\x5e\x02\x81\xc9\x03\x66\x3f\xab\x97\x09\x0e\x1f\x04\x8e\x9c\xce\x91\xa4\x24\x8b\xd2\xd6\x51\x7f\xbd\x6a\x30\x27\xd9\x80\x63\x81\xcc\x26\x57\x98\xa0\xc1\xac\xd1\x74\xd4\xa0\x52\xe1\xc2\x8e\x89\xa1\xf1\xee\x4a\x91\x6f\xed\x01\x79\x6e\x3a\x75\x29\xaf\x7b\x0e\x81\xdc\x0a\x69\xb8\xd7\x2a\x05\xf4\x02\xef\x8a\x83\x37\xd8\x58\xc5\xee\xd6\x85\x4f\x91\xa9\xb9\xdd\x9b\x84\x83\xf6\x4b\x21\x46\x80\x9d\x19\x11\x2a\x71\x91\x5a\xe4\x45\xb6\xcc\xda\xc2\xa2\xe4\x4c\x85\xb6\x3f\x1e\xf2\x2e\xfb\x5a\x1a\x23\x0b\xc0\x7b\x11\x9d\x4b\xbe\xe6\xa5\xe2\xf8\xcc\x2d\x5e\x7f\x32\x4f\x60\x2a\x5e\x52\x53\x20\x6b\x4e\x5a\xd6\xef\x95\xc7\x13\x29\x5d\x0d\x19\xa6\x08\xd9\x07\x1e\x6f\x0c\x4c\xb9\x81\x11\xba\x65\x1d\xd8\x94\x54\x0e\x84\xc2\x7a\x84\x08\x4b\xbc\x0d\x31\x78\x39\x72\x7c\x5a\x89\xcb\x6e\xf4\x9e\x42\x90\x7b\x48\x6d\xa0\x8f\x14\xc2\x72\xe7\x64\x35\xff\x87\x9c\xd4\x80\x40\x80\x1a\xcc\x90\x87\x97\xd4\x6e\xf2\xdd\xf3\xaa\x09\x52\x0a\xf9\x91\x46\xae\x97\xdc\x81\xde\xaa\x47\x47\xdc\x9d\xdb\x43\x85\x6d\x40\xe1\x9c\x9d\x62\xe8\x2d\x0f\x11\x7d\x9c\x7d\xa0\xfb\x01\xdf\x39\x74\x0e\x98\xf1\x95\xd7\xdc\xa4\xe5\x6d\x3d\x10\x25\xfc\x2b\x90\x5f\x77\xea\xbb\xda\xea\x7e\x9d\x29\x2c\x43\xd8\x0f\xb9\x34\x4e\x6a\x7e\x02\xea\xe9\x91\x56\x70\x96\x6f\xd0\x3d\xe7\xdc\xe0\xdd\x62\x77\x30\x2a\x3e\xf1\x9e\xb6\x74\xcc\x77\xea\x49\x64\xd6\x94\x24\x97\xae\x54\x8f\x1d\x45\x49\x87\xe0\x27\x5b\x73\xf3\x38\xcc\xdd\x58\x2d\xcd\x1c\x7e\x05\x16\xe2\xb8\x4c\xdf\xcc\x35\xc9\x3e\xc2\x96\x2f\x81\x63\x05\xdd\x63\xfb\xbd\xf2\x47\x10\x63\x2c\x69\xc4\xdb\x80\x09\xe6\x0b\x22\x3f\x38\x09\x75\xde\x6d\x6e\xb9\xcc\x20\xbb\x6e\x42\xa4\x10\x47\xa7\x06\xd6\x23\x37\xc0\xe6\x08\x61\xad\x59\x5b\x5c\x08\x3d\x84\x22\x36\x1d\xe6\x62\x5e\x02\x40\x78\x7d\x72\xde\xcb\x8e\x60\x70\x3d\x0a\xf0\x20\x83\xb8\xe1\x0e\x61\x70\x42\xa2\x5f\xf9\xd9\xe0\x32\xa6\x15\xc1\xa4\x5e\x7a\x73\x1b\x99\x1a\x66\x99\x0a\x10\x2c\x2c\x64\xc3\x4f\x63\xc3\xb8\x7d\x51\xcc\x21\x95\xc6\x2a\xd9\xc7\xad\x77\xee\xa5\xed\x46\xbe\xe9\x4e\x2a\xac\x77\x9a\x1c\x85\x3c\x5f\x38\x6a\xa8\x4b\x81\xe1\x26\x43\x26\xf3\x70\x47\x48\x41\x18\xef\x1a\xde\xaa\x2b\x63\xba\x28\xa3\x8d\x8b\xda\xaa\x07\xfb\x8b\x7b\x81\x1a\x58\xce\xe7\x6c\xa3\xe9\x53\xbb\x40\x2d\x03\x82\x26\x46\x5e\xb4\x2e\xe5\x65\x78\xb5\x8b\x6e\x01\x7d\x84\x63\xd8\x70\x86\x7e\x19\xdb\x4d\x37\xc3\xce\x18\x54\xaa\x0e\x1b\x42\xf7\x85\x8e\x9c\x1e\x56\x1f\x10\x96\xda\xe1\xef\x0e\xd9\x10\x09\xf8\x76\x99\x51\x63\x1d\x7a\x73\x4d\x7e\xb7\x06\x92\x61\xe9\x3c\xaa\x7f\x8f\x09\x42\x2a\xbb\xa5\x17\xaf\x2b\xe1\x38\x59\xf1\xe7\x86\xde\x55\xca\xd9\xab\x80\xc5\xe5\x06\xb2\xbb\x89\xe2\xaa\x21\x8d\x20\xdc\x4c\x6a\x96\xe0\x78\x22\x83\x96\x2b\xe1\x94\x94\x62\xd0\x75\x4c\x60\xd4\x4d\x53\x2c\xd7\x76\x1b\x7a\x23\xe5\xa3\x8f\xbd\x0d\x3e\x0b\x47\x2d\xd0\x8b\x09\x8a\x14\x9c\xfc\x8a\x13\xc7\x98\x5d\xd7\x9b\x5c\xb5\xef\x22\xfa\x92\xa2\xc3\xf1\x9f\x96\x08\x3b\xbc\x0d\x1b\x12\x1f\xd7\x7c\x03\x10\x87\x27\x98\xd6\x1f\xac\x5b\x17\xcf\x4f\xc2\x06\x8e\x13\xb9\x94\x06\x02\x3f\x7b\xa6\x29\x50\xb1\xc5\x65\x8a\x3c\x7a\xe3\xa1\xa3\x33\x79\xc3\x90\x5b\xf9\x19\x77\xc7\x06\xb7\xc4\x2a\x26\x4e\x69\x35\xd7\xbb\x30\xd6\x54\x81\x8e\x29\x0b\x01\x56\x73\xba\x5f\x5f\x9f\x9f\xd8\x7e\x8c\x8e\xc0\x05\xe6\x44\x27\x1b\x1f\x28\xa1\x6f\x0e\x27\x5d\x1d\xdc\xd5\xa2\x40\xf1\xf2\x4e\xb9\x65\x77\xcd\xc1\x7d\xa2\x7d\x4a\xdc\x58\x41\x09\x43\x65\x56\xf7\x42\x02\xd9\x90\x21\xd8\x51\x4a\x49\x2b\x2b\xd3\x79\x47\x53\xf7\x8d\xc3\x07\xe7\x08\x25\x8c\x9e\xc0\xd8\xa4\x6c\x94\x59\x50\x60";

		KeyPairNtru::new(private.into(), public.into())
	}

	fn bob_signed_prekey() -> SignedKeyPairX448 {
		let private = b"\x98\xbe\x16\x21\x67\xc5\x2b\x75\x5d\xae\xaa\x18\xf0\xcf\xbb\x5b\x8d\x0a\x80\x23\xcd\x6e\x78\xd0\xe8\x47\xdc\xe1\x98\x3e\x39\x8c\x67\x11\x2b\xa8\x02\x9e\xf8\x6b\xe7\x2f\x18\xc2\xe8\x07\x0e\x24\x8e\xed\x73\x93\xbb\x5d\x73\x9b";
		let public = b"\x36\xcb\x46\x0b\xd7\xcb\x41\xe3\xd6\x24\x0a\x25\x6b\x46\xda\xc5\x7f\xeb\x1e\x71\x38\x7f\x93\x1f\x86\xdb\x4d\xde\xd1\x1d\x72\x34\x5d\xe0\x51\x1f\xe4\xa4\xf0\xe9\x26\x01\x1c\xf2\x12\x2e\xd6\x40\x8f\x2c\x4b\xe0\xbf\x92\x2c\x1a";
		let kp = KeyPairX448::new(private.into(), public.into());

		SignedKeyPairX448::new(kp.private_key().clone(), SignedPublicKeyX448::new(kp.public_key().clone(), bob_ed448_identity().private_key().sign(kp.public_key().as_bytes())))
	}

	pub fn alice_session() -> Session {
		Session::alice(
			alice_x448_identity(),
			alice_ephemeral(),
			alice_ed448_identity(),
			alice_ntru_identity(),
			alice_ntru_ratchet(),
			bob_x448_identity().public_key().clone(),
			bob_signed_prekey().public().clone(),
			bob_x448_prekey().public_key().clone(),
			bob_ntru_prekey().public_key().clone(),
			bob_ntru_identity().public_key().clone(),
			false)
	}

	fn bob_session(kex: &KeyExchange) -> Session {
		let decrypted = decrypt_kex(kex);
		Session::bob(
			bob_x448_identity(),
			bob_ntru_identity(), 
			bob_signed_prekey(), 
			bob_x448_prekey(), 
			bob_ntru_prekey(), 
			kex.x448_identity.clone(), 
			decrypted.ephemeral.clone(), 
			decrypted.ntru.clone())
	}

	fn decrypt_kex(kex: &KeyExchange) -> NtruedKeys {
		let bob_ntru_prekey = bob_ntru_prekey();

		let find_key = |_| -> Result<&PrivateKeyNtru, ntru::Error> {
			Ok(bob_ntru_prekey.private_key())
		};

		ntru::decrypt_ephemeral(&kex.ntru_encrypted_ephemeral, ntru::DecryptionMode::Double { second_key: bob_ntru_identity().private_key(), first_key: Box::new(find_key) }).unwrap()
	}

	fn turn_ratchet(alice: &mut Session, bob: &mut Session) -> (AxolotlMac, AxolotlMac) {
		let msg1 = alice.encrypt(b"turning", Type::Chat);
		_ = bob.decrypt(&msg1);

		let msg2 = bob.encrypt(b"turning", Type::Chat);
		_ = alice.decrypt(&msg2);

		(msg1, msg2)
	}

	#[test]
	fn test_encrypt_decrypt() {
		let mut alice = alice_session();
		let a0 = alice.encrypt(b"hi 0", Type::Chat);
		let a1 = alice.encrypt(b"hi 1", Type::Chat);
		let a2 = alice.encrypt(b"hi 2", Type::Chat);

		// alice updated her internal state
		assert_eq!(alice.counter, 3);
		assert_eq!(alice.prev_counter, 0);
		assert!(alice.unacked_key_exchange.is_some());

		// all unacked messages are to include a kex
		assert!(a0.body().key_exchange.is_some());
		assert!(a1.body().key_exchange.is_some());
		assert!(a2.body().key_exchange.is_some());

		// all unacked messages are to have an ntru encrypted eph (and no ratchet_key yet)
		assert!(a0.body().ratchet_key.is_none());
		assert!(a1.body().ratchet_key.is_none());
		assert!(a2.body().ratchet_key.is_none());
		assert!(a0.body().ntru_encrypted_ratchet_key.is_some());
		assert!(a1.body().ntru_encrypted_ratchet_key.is_some());
		assert!(a2.body().ntru_encrypted_ratchet_key.is_some());

		// now, bob decrypts the messages
		let mut bob = bob_session(&a1.body().clone().key_exchange.unwrap());
		let rcvd0 = bob.decrypt(&a0).unwrap();
		let rcvd1 = bob.decrypt(&a1).unwrap();
		let rcvd2 = bob.decrypt(&a2).unwrap();

		assert_eq!(rcvd0, b"hi 0");
		assert_eq!(rcvd1, b"hi 1");
		assert_eq!(rcvd2, b"hi 2");

		// counter should not yet change for bob (it's for sending)
		assert_eq!(bob.counter, 0);
		assert_eq!(bob.prev_counter, 0);
		assert!(bob.unacked_key_exchange.is_none());

		// make bob send a message to alice to ratchet once
		let b0 = alice.decrypt(&bob.encrypt(b"hi from bob", Type::Chat)).unwrap();

		assert_eq!(b0, b"hi from bob");

		// now, bob should change his internal sending state
		assert_eq!(bob.counter, 1);
		assert_eq!(bob.prev_counter, 0);
		// bob didn't start this conversation, so he should not have a kex
		assert!(bob.unacked_key_exchange.is_none());

		// now, alice sends a few more messages with a new ratchet
		let a3 = alice.encrypt(b"hi 3", Type::Chat);
		let a4 = alice.encrypt(b"hi 4", Type::Chat);
		let a5 = alice.encrypt(b"hi 5", Type::Chat);

		// make sure no key exchange is present for this ratchet (attached for the first unacked messages only)
		assert!(a3.body().key_exchange.is_none());
		assert!(a4.body().key_exchange.is_none());
		assert!(a5.body().key_exchange.is_none());

		// and unacked_key_exchange is cleared
		assert!(alice.unacked_key_exchange.is_none());

		// as well as no ntru_encrypted_ratchet_key is applied while ratchet_key is set
		assert!(a3.body().ratchet_key.is_some());
		assert!(a4.body().ratchet_key.is_some());
		assert!(a5.body().ratchet_key.is_some());
		assert!(a3.body().ntru_encrypted_ratchet_key.is_none());
		assert!(a4.body().ntru_encrypted_ratchet_key.is_none());
		assert!(a5.body().ntru_encrypted_ratchet_key.is_none());

		// also, alice's internal state should update
		assert_eq!(alice.counter, 3);
		assert_eq!(alice.prev_counter, 3);
		
		let rcvd3 = bob.decrypt(&a3).unwrap();
		let rcvd4 = bob.decrypt(&a4).unwrap();
		let rcvd5 = bob.decrypt(&a5).unwrap();

		// now bob decrypts the messages with his new derived ratchet
		assert_eq!(rcvd3, b"hi 3");
		assert_eq!(rcvd4, b"hi 4");
		assert_eq!(rcvd5, b"hi 5");
	}

	#[test]
	fn test_force_ntru() {
		let mut alice = alice_session();
		let a0 = alice.encrypt(b"hi 0", Type::Chat);
		let a1 = alice.encrypt(b"hi 1", Type::Chat);
		let a2 = alice.encrypt(b"hi 2", Type::Chat);

		// all unacked messages are to have an ntru encrypted eph (and no ratchet_key yet)
		assert!(a0.body().ratchet_key.is_none());
		assert!(a1.body().ratchet_key.is_none());
		assert!(a2.body().ratchet_key.is_none());
		assert!(a0.body().ntru_encrypted_ratchet_key.is_some());
		assert!(a1.body().ntru_encrypted_ratchet_key.is_some());
		assert!(a2.body().ntru_encrypted_ratchet_key.is_some());

		// now, bob decrypts the messages
		let mut bob = bob_session(&a1.body().clone().key_exchange.unwrap());
		_ = bob.decrypt(&a0).unwrap();
		_ = bob.decrypt(&a1).unwrap();
		_ = bob.decrypt(&a2).unwrap();

		// make bob send a message to alice to ratchet once
		_ = alice.decrypt(&bob.encrypt(b"hi from bob", Type::Chat)).unwrap();

		// now, alice sends a few more messages with a new ratchet
		let a3 = alice.encrypt(b"hi 3", Type::Chat);
		let a4 = alice.encrypt(b"hi 4", Type::Chat);
		let a5 = alice.encrypt(b"hi 5", Type::Chat);

		// as well as no ntru_encrypted_ratchet_key is applied while ratchet_key is set
		assert!(a3.body().ratchet_key.is_some());
		assert!(a4.body().ratchet_key.is_some());
		assert!(a5.body().ratchet_key.is_some());
		assert!(a3.body().ntru_encrypted_ratchet_key.is_none());
		assert!(a4.body().ntru_encrypted_ratchet_key.is_none());
		assert!(a5.body().ntru_encrypted_ratchet_key.is_none());
		
		// now, bob decrypts 
		_ = bob.decrypt(&a3).unwrap();
		_ = bob.decrypt(&a4).unwrap();
		_ = bob.decrypt(&a5).unwrap();

		_ = alice.decrypt(&bob.encrypt(b"meaning of life, please?", Type::Chat)).unwrap();

		// now, make alice ntru-encrypt her next message's ratchet
		alice.force_ntru_for_next();

		let a6 = alice.encrypt(b"42", Type::Chat);
		let a7 = alice.encrypt(b"or not", Type::Chat);

		// and notice the messages are encrypted with an ntru encrypted ratchet
		assert!(a6.body().ratchet_key.is_none());
		assert!(a7.body().ratchet_key.is_none());
		assert!(a6.body().ntru_encrypted_ratchet_key.is_some());
		assert!(a7.body().ntru_encrypted_ratchet_key.is_some());

	}

	#[test]
	fn test_keys_used_for_kex() {
		let msg = alice_session().encrypt(b"hi", Type::Chat);
		let kex = msg.body().key_exchange.as_ref().unwrap();

		// I used one of your prekeys for this session
		assert_eq!(kex.x448_prekey_id, bob_x448_prekey().public_key().id());
		// as well as one of your signed prekeys
		assert_eq!(kex.signed_prekey_id, bob_signed_prekey().public().key().id());
		// and this is my identity in turn
		assert_eq!(kex.x448_identity.id(), alice_x448_identity().public_key().id());
		// my ntru-encrypted ratchet
		assert_eq!(kex.ntru_encrypted_ephemeral.key_id, alice_ephemeral().public_key().id());
		// it is double encrypted, by the way,
		assert!(kex.ntru_encrypted_ephemeral.double_encrypted);
		// with your ntru identity first (and another key on top)
		assert_eq!(kex.ntru_encrypted_ephemeral.payload.encryption_key_id, bob_ntru_identity().public_key().id());
		// this is my ntru identity (not used by Session actually, but we have it in protobuf)
		assert_eq!(kex.ntru_identity.id(), alice_ntru_identity().public_key().id());
		// and my signing key
		assert_eq!(kex.ed448_identity.id(), alice_ed448_identity().public_key().id());
	}

	#[test]
	fn test_ntru_encrypt_ratchet() {
		let mut alice = alice_session();
		let a0 = alice.encrypt(b"hi 0", Type::Chat);
		let kex = a0.body().key_exchange.as_ref().unwrap();

		// all unacked messages are to have a kex containing a double encrypted eph: first, it's 
		// encrypted with bob's ntru prekey, then â€“ his ntru identity
		assert_eq!(alice.ratchet_counter, 1);
		assert!(kex.ntru_encrypted_ephemeral.double_encrypted);
		assert_eq!(kex.ntru_encrypted_ephemeral.payload.encryption_key_id, bob_ntru_identity().public_key().id());
		// while initial ntru encrypted ratchet eph is never double encrypted
		assert_eq!(a0.body().ntru_encrypted_ratchet_key.as_ref().unwrap().double_encrypted, false);
		// bob's prekey is used as his first ntru ratchet to encrypt alice's eph ratchet
		assert_eq!(a0.body().ntru_encrypted_ratchet_key.as_ref().unwrap().payload.encryption_key_id, bob_ntru_prekey().public_key().id());
		// plain ratchet eph should be None, by the way
		assert!(a0.body().ratchet_key.is_none());

		let mut bob = bob_session(kex);
		// turn once for bob to start using plain eph ratchet
		_ = bob.decrypt(&a0);
		// and for alice
		_ = alice.decrypt(&bob.encrypt(b"hi, alice 0", Type::Chat));

		// still 1 for alice
		assert_eq!(alice.ratchet_counter, 1);
		assert_eq!(bob.ratchet_counter, 1);

		// turn the root key N - 1 more times, in other words right before both sides decide to exchange a new NTRU key
		for ctr in 2..RATCHETS_BETWEEN_NTRU + 1 {
			let (a, b) = turn_ratchet(&mut alice, &mut bob);

			assert_eq!(alice.ratchet_counter, ctr);
			assert_eq!(bob.ratchet_counter, ctr);
			// at this point, non-ntru-encrypted ratchet shoudl be used
			assert!(a.body().ntru_encrypted_ratchet_key.is_none());
			assert!(a.body().ratchet_key.is_some());
			assert!(b.body().ntru_encrypted_ratchet_key.is_none());
			assert!(b.body().ratchet_key.is_some());
		}

		let a1 = alice.encrypt(b"this goes with a new ntru encrypted ratchet by alice", Type::Chat);

		// now, on the Nth turn, alice includes a new ntru key, encrypted with bob's ntru ratchet; no plain ratchet is used
		assert!(a1.body().ratchet_key.is_none());
		// again, it should not be double encrypted (double encryption is used for kex only)
		assert_eq!(a1.body().ntru_encrypted_ratchet_key.as_ref().unwrap().double_encrypted, false);

		// make sure different ephemeral keys are used between the ratchets
		assert_ne!(a0.body().ntru_encrypted_ratchet_key.as_ref().unwrap().key_id, a1.body().ntru_encrypted_ratchet_key.as_ref().unwrap().key_id);
		// it's still the same old bob's ntru ratchet (= bob ntru prekey) for alice
		assert_eq!(a1.body().ntru_encrypted_ratchet_key.as_ref().unwrap().payload.encryption_key_id, a0.body().ntru_encrypted_ratchet_key.as_ref().unwrap().payload.encryption_key_id);

		_ = bob.decrypt(&a1);

		// here, bob will use alice's new ntru ratchet
		let b0 = bob.encrypt(b"this goes with a new ntru encrypted ratchet by bob", Type::Chat);

		assert!(b0.body().ntru_encrypted_ratchet_key.is_some());
		assert!(b0.body().ratchet_key.is_none());
		// as usual, no double encryption
		assert_eq!(b0.body().ntru_encrypted_ratchet_key.as_ref().unwrap().double_encrypted, false);
		// bob's eph is encrypted with alice's most recent ntru ratchet
		assert_eq!(b0.body().ntru_encrypted_ratchet_key.as_ref().unwrap().payload.encryption_key_id, alice.my_ntru_ratchet.as_ref().unwrap().public_key().id());

		_ = alice.decrypt(&b0);

		// and finally, switch back to plain ratchets again
		let a2 = alice.encrypt(b"now, no ntru ratchet will be used by alice", Type::Chat);
		assert!(a2.body().ntru_encrypted_ratchet_key.is_none());
		assert!(a2.body().ratchet_key.is_some());

		// and same for bob
		_ = bob.decrypt(&a2);
		let b1 = bob.encrypt(b"now, this goes with a plain ratchet by bob as well", Type::Chat);

		assert!(b1.body().ntru_encrypted_ratchet_key.is_none());
		assert!(b1.body().ratchet_key.is_some());
	}

	#[test]
	fn test_decrypt_skipped_ntru_ratchet() {
		// make alice and bob turn once by sending each other 1 message each
		let mut alice = alice_session();
		let a0 = alice.encrypt(b"hi, bob 0", Type::Chat);
		let mut bob = bob_session(&a0.body().key_exchange.as_ref().unwrap());
		_ = bob.decrypt(&a0);
		_ = alice.decrypt(&&bob.encrypt(b"hi, alice 0", Type::Chat));

		// now, turn N - 1 times, just before exchanging a new ntru ratchet key
		for _ in 1..RATCHETS_BETWEEN_NTRU {
			_ = turn_ratchet(&mut alice, &mut bob);
		}

		let msg_to_skip = b"this one goes with a new ntru ratchet by alice";
		let a1 = alice.encrypt(msg_to_skip, Type::Chat);
		// so, we have a message from alice with an ntru encrypted ratchet
		assert!(a1.body().ntru_encrypted_ratchet_key.is_some());

		// make alice and bob completely switch to new ratchets by turnig a lot
		for _ in 1..RATCHETS_BETWEEN_NTRU * 5 {
			_ = turn_ratchet(&mut alice, &mut bob);
		}

		// current and "forgotten" chains should be kept by now
		assert_eq!(bob.receive_chain.len(), 2);

		let skipped = bob.decrypt(&a1).unwrap();
		assert_eq!(msg_to_skip, &skipped[..]);
		// when the lost message is decrypted, its chain is disposed (given it was just one such message)
		assert_eq!(bob.receive_chain.len(), 1);
	}

	#[test]
	fn test_decrypt_out_of_order() {
		let mut alice = alice_session();
		let a0 = alice.encrypt(b"a0", Type::Chat);
		let a1 = alice.encrypt(b"a1", Type::Chat);
		let a2 = alice.encrypt(b"a2", Type::Chat);
		let a3 = alice.encrypt(b"a3", Type::Chat);

		let mut bob = bob_session(&a0.body().key_exchange.as_ref().unwrap());

		assert_eq!(b"a3", &bob.decrypt(&a3).unwrap()[..]);
		assert_eq!(b"a0", &bob.decrypt(&a0).unwrap()[..]);
		assert_eq!(b"a2", &bob.decrypt(&a2).unwrap()[..]);
		assert_eq!(b"a1", &bob.decrypt(&a1).unwrap()[..]);
	}

	#[test]
	fn test_dispose_chain_when_no_skipped_messages_left() {
		let mut alice = alice_session();
		let a0 = alice.encrypt(b"hi, bob 0", Type::Chat);
		let mut bob = bob_session(&a0.body().key_exchange.as_ref().unwrap());

		_ = bob.decrypt(&a0);
		_ = alice.decrypt(&bob.encrypt(b"hi, alice 0", Type::Chat));

		// with one message sent, alice and bob each has 1 chain-sized receive chains respectively
		assert_eq!(alice.receive_chain.len(), 1);
		assert_eq!(bob.receive_chain.len(), 1);

		// encrypt a message that will be decrypted by bob later making him preserve a chain for that
		let a1 = alice.encrypt(b"this one will be skipped for now", Type::Chat);

		_ = bob.decrypt(&alice.encrypt(b"this will be decrypted by a new chain", Type::Chat));
		// and turn several times to swich to new ratchets
		turn_ratchet(&mut alice, &mut bob);
		turn_ratchet(&mut alice, &mut bob);

		// there were three chains: (1) initial chain w/ skipped key, (2) no skipped, and (3) current
		// 2 would be cleaned up immediately since it has no skipped keys and is replaced by 3 (those turn_ratchet calls)
		assert_eq!(bob.receive_chain.len(), 2);
		// alice doesn't have any skipped messages, so she has only one chain â€“ current
		assert_eq!(alice.receive_chain.len(), 1);

		// decrypt bob's skipped message and ensure he only has on (current) chain left
		_ = bob.decrypt(&a1);
		assert_eq!(bob.receive_chain.len(), 1);
	}

	#[test]
	fn test_fail_when_skipped_too_many_keys() {
		let mut alice = alice_session();
		let a0 = alice.encrypt(b"hi 0", Type::Chat);
		let mut valid_messages: Vec<AxolotlMac> = (1..chain::MAX_KEYS_TO_SKIP + 1)
				.into_iter()
				.map(|ctr| alice.encrypt(format!("skipped {}", ctr).as_bytes(), Type::Chat)).collect();
		let last_valid = valid_messages.pop().unwrap();
		// this generates a message with a large counter
		let invalid_msg = alice.encrypt(b"invalid", Type::Chat);
		let mut bob = bob_session(&a0.body().key_exchange.as_ref().unwrap());

		// the very first message decrypts just fine for it has a small ctr
		assert_eq!(bob.decrypt(&a0).unwrap(), b"hi 0");
		assert_eq!(bob.decrypt(&invalid_msg).err(), Some(Error::TooManyKeySkipped));
		// this last valid one decrypts just fine
		assert_eq!(bob.decrypt(&last_valid).unwrap(), format!("skipped {}", chain::MAX_KEYS_TO_SKIP).as_bytes());
		// as well as this one, since we've just freed one slot to store
		assert_eq!(bob.decrypt(&invalid_msg).unwrap(), b"invalid");

		// and the process goes endlessly
		for ctr in 0..10 {
			// when there's one last message that can be decrypted
			let valid = alice.encrypt(format!("skipped {}", ctr).as_bytes(), Type::Chat);
			// while the next one fails
			let invalid = alice.encrypt(format!("failing {}", ctr).as_bytes(), Type::Chat);
			
			assert_eq!(bob.decrypt(&invalid).err(), Some(Error::TooManyKeySkipped));
			// until there's a slot to process a skipped key
			assert_eq!(bob.decrypt(&valid).unwrap(), format!("skipped {}", ctr).as_bytes());
			assert_eq!(bob.decrypt(&invalid).unwrap(), format!("failing {}", ctr).as_bytes());
		}

		// but then, we can decrypt all those pending messages
		valid_messages.iter().enumerate().for_each(|(i, msg)| {
			assert_eq!(bob.decrypt(&msg).unwrap(), format!("skipped {}", i + 1).as_bytes());
		});

		// and encrypt/decrypt new messages within this same chain
		let a1 = alice.encrypt(b"a1", Type::Chat);
		let a2 = alice.encrypt(b"a2", Type::Chat);
		let a3 = alice.encrypt(b"a3", Type::Chat);

		assert_eq!(bob.receive_chain.len(), 1);
		assert_eq!(bob.decrypt(&a1).unwrap(), b"a1");
		assert_eq!(bob.decrypt(&a2).unwrap(), b"a2");
		assert_eq!(bob.decrypt(&a3).unwrap(), b"a3");
	}

	#[test]
	fn test_invalid_mac() {
		let mut alice = alice_session();
		let a0 = alice.encrypt(b"a0", Type::Chat);
		let mut bob = bob_session(&a0.body().key_exchange.as_ref().unwrap());

		// the first one decrypts fine
		assert_eq!(bob.decrypt(&a0).unwrap(), b"a0");
		let mut a1 = alice.encrypt(b"a1", Type::Chat);
		a1.set_mac(hmac::digest(&hmac::Key::new([42u8; 32]), b"fake message"));

		assert_eq!(bob.decrypt(&a1).err(), Some(Error::WrongMac));
	}
}

mod serialize {
	#[derive(Debug)]
	pub enum Error {
		NoId,
		NoRole,
		BadRole,
		NoCounter,
		NoPrevCounter,
		NoRatchetCounter,
		BadMyNtruIdentity,
		BadMyRatchet,
		BadMyNtruRatchet,
		BadTheirRatchet,
		NoTheirRatchetNtru,
		BadTheirNtruRatchet,
		BadKeyExchange,
		BadRootKey,
		NoRootKey,
		BadSendChainKey,
		BadReceiveChain,
		BadFormat,
NoReceiveOnly,
	}

	impl TryFrom<u32> for Role {
		type Error = Error;

		fn try_from(value: u32) -> Result<Self, Self::Error> {
			match value {
				0 => Ok(Self::Alice),
				1 => Ok(Self::Bob),
				_ => Err(Error::BadRole)
			}
		}
	}

	use crate::{serializable::{Serializable, Deserializable}, proto, ntru::{KeyPairNtru, PublicKeyNtru}, x448::{KeyPairX448, PublicKeyX448}, key_exchange::KeyExchange, root_key::RootKey, chain_key::ChainKey, receive_chain::ReceiveChain};
	use super::{Session, Role};
	use prost::Message;

	impl From<&Session> for proto::SessionState {
		fn from(src: &Session) -> Self {
			Self {
				id: Some(src.id),
				role: Some(src.role as u32),
				their_identity: None,
				root_key: Some(src.root_key.as_bytes().to_vec()),
				send_chain_key: src.send_chain_key.as_ref().map(|k| k.into()),
				receive_chain: (&src.receive_chain).into(),
				my_ratchet: src.my_ratchet.as_ref().map(|r| r.serialize()),
				their_ratchet: src.their_ratchet.as_ref().map(|r| r.as_bytes().to_vec()),
				ratchet_flag: None,
				counter: Some(src.counter),
				prev_counter: Some(src.prev_counter),
				key_exchange: src.unacked_key_exchange.as_ref().map(|kex| kex.into()),
				alice_base_key: None,
				my_ratchet_ntru_key: src.my_ntru_ratchet.as_ref().map(|r| r.serialize()),
				their_ratchet_ntru_key: Some(src.their_ratchet_ntru.as_bytes().to_vec()),
				ratchet_counter: Some(src.ratchet_counter),
				my_ntru_identity: src.my_ntru_identity.as_ref().map(|i| i.serialize()),
				failed: Some(false),
				receive_only: Some(src.receive_only)
			}
		}
	}

	impl Serializable for Session {
		fn serialize(&self) -> Vec<u8> {
			proto::SessionState::from(self).encode_to_vec()
		}
	}

	impl TryFrom<proto::SessionState> for Session {
    type Error = Error;

    fn try_from(value: proto::SessionState) -> Result<Self, Self::Error> {
			Ok(Self {
				id: value.id.ok_or(Error::NoId)?,
				role: value.role.map_or(Err(Error::NoRole), |r| Role::try_from(r))?,
				receive_only: value.receive_only.ok_or(Error::NoReceiveOnly)?,
				counter: value.counter.ok_or(Error::NoCounter)?,
				prev_counter: value.prev_counter.ok_or(Error::NoPrevCounter)?,
				ratchet_counter: value.ratchet_counter.ok_or(Error::NoRatchetCounter)?,
				my_ntru_identity: value.my_ntru_identity.map_or(Ok(None), |i| Ok(Some(KeyPairNtru::deserialize(&i).or(Err(Error::BadMyNtruIdentity))?)))?,
				my_ratchet: value.my_ratchet.map_or(Ok(None), |r| Ok(Some(KeyPairX448::deserialize(&r).or(Err(Error::BadMyRatchet))?)))?,
				my_ntru_ratchet: value.my_ratchet_ntru_key.map_or(Ok(None), |i| Ok(Some(KeyPairNtru::deserialize(&i).or(Err(Error::BadMyNtruRatchet))?)))?,
				their_ratchet: value.their_ratchet.map_or(Ok(None), |r| Ok(Some(PublicKeyX448::try_from(r).or(Err(Error::BadTheirRatchet))?)))?,
				their_ratchet_ntru: PublicKeyNtru::try_from(value.their_ratchet_ntru_key.ok_or(Error::NoTheirRatchetNtru)?).or(Err(Error::BadTheirNtruRatchet))?,
				unacked_key_exchange: value.key_exchange.map_or(Ok(None), |kex| Ok(Some(KeyExchange::try_from(kex).or(Err(Error::BadKeyExchange))?)))?,
				root_key: RootKey::try_from(value.root_key.ok_or(Error::NoRootKey)?).or(Err(Error::BadRootKey))?,
				send_chain_key: value.send_chain_key.map_or(Ok(None), |k| Ok(Some(ChainKey::try_from(k).or(Err(Error::BadSendChainKey))?)))?,
				receive_chain: ReceiveChain::try_from(value.receive_chain).or(Err(Error::BadReceiveChain))?
			})
    }
}

	impl Deserializable for Session {
		type Error = Error;

		fn deserialize(buf: &[u8]) -> Result<Self, Self::Error> where Self: Sized {
			Self::try_from(proto::SessionState::decode(buf).or(Err(Error::BadFormat))?)
		}
	}

	#[cfg(test)]
	mod tests {
    use crate::{serializable::{Serializable, Deserializable}, session::Session};

		#[test]
		fn test_serialize_deserialize() {
			let session = super::super::tests::alice_session();
			let serialized = session.serialize();
			let deserialized = Session::deserialize(&serialized).unwrap();

			assert_eq!(session, deserialized);
		}
	}
}